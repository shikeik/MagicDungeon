# 权重系统设计方案

## 1. 现状分析
当前 `PolyBatchTestScreen` 中的披风模拟使用了硬编码的权重计算方式：
```java
float factor = 1.0f - (oldY / h);
```
权重仅与顶点的 Y 坐标（高度）相关，无法精细控制每个部位的摆动幅度。

## 2. 目标
实现可配置的权重系统，允许用户手动编辑每个控制点的权重，并用于动画计算。

## 3. 方案设计

### 3.1 数据结构重构
引入 `ControlPoint` 类，替代原有的 `Vector2`。
```java
public class ControlPoint {
    public Vector2 position;
    public float weight; // 0.0 (红) ~ 1.0 (绿)

    public ControlPoint(float x, float y, float weight) {
        this.position = new Vector2(x, y);
        this.weight = weight;
    }
}
```
修改 `CapeState` 类：
- `hullPoints`: `Array<Vector2>` -> `Array<ControlPoint>`
- `interiorPoints`: `Array<Vector2>` -> `Array<ControlPoint>`
- `allPoints`: 同样存储 `ControlPoint` 引用，保持顺序。

### 3.2 权重计算逻辑更新
在 `updateAnimation` 中，不再计算 Y 轴线性插值，而是直接读取对应顶点的权重。
由于 `originalVertices` 是由 `allPoints` 扁平化生成的，索引 `i/2` 对应 `allPoints.get(i/2)`。
```java
// 旧逻辑
// float factor = 1.0f - (oldY / h);

// 新逻辑
int pointIndex = i / 2;
float factor = allPoints.get(pointIndex).weight;
```

### 3.3 交互模式：权重刷 (Weight Brush)
新增 `Mode.WEIGHT` 模式。
在此模式下：
1.  **可视化**：
    - 每个控制点周围绘制一个有厚度的环形图标。
    - 颜色根据权重渐变：0.0 (Red) -> 0.5 (Yellow) -> 1.0 (Green)。
    - 使用 `ShapeRenderer` 绘制同心圆来模拟厚度。
2.  **交互**：
    - 鼠标左键点击/拖动经过点时，应用当前“笔刷权重”。
    - 提供 UI 滑块设置“笔刷权重”值（0~1）和“笔刷半径”。
    - 或者简化为：选中点后，通过快捷键或 UI 滑块修改其权重。
    - 为了“模仿 Spine 权重刷”，支持按住鼠标移动时，更新鼠标范围内的点权重。

### 3.4 UI 更新
1.  **右侧列表**：
    - 列表项不仅显示 UV，还要显示当前权重值。
    - 最好能直接在列表中修改（如果 UI 库支持），或者点击选中后在下方面板修改。
2.  **参数面板**：
    - 在 `WEIGHT` 模式下，显示“笔刷设置”面板（目标权重、强度/不透明度、半径）。

## 4. 任务拆解
1.  **数据重构**：定义 `ControlPoint`，修改 `CapeState` 数据结构，修复编译错误（`generateMesh` 等）。
2.  **逻辑更新**：修改 `updateAnimation` 使用存储的权重。
3.  **渲染更新**：实现 `drawMeshDebug` 中的权重圆环绘制。
4.  **交互实现**：在 `EditorInputHandler` 中添加 `WEIGHT` 模式的处理逻辑（刷权重）。
5.  **UI 完善**：更新右侧列表显示，添加权重刷工具栏。
6.  **序列化**：更新 JSON 加载/保存逻辑以支持权重数据。

