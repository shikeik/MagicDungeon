# 双网格系统应用方案

## 1. 概述
本方案旨在将演示场景中的“双网格（Dual Grid）”系统应用到地牢游戏的主渲染流程中，以实现平滑的地形过渡效果（如草地、泥土、沙地之间的自然拼接）。

## 2. 现有系统分析
目前的 `DualGridDemoScreen` 实现了完整的双网格逻辑：
- **数据结构**：使用三维数组 `GridData` 存储多层地形数据。
- **Mask计算**：通过计算每个交点周围 4 个格子的状态（TL, TR, BL, BR）生成 0-15 的 Mask。
- **渲染映射**：将 Mask 映射到 4x4 的 Blob Tileset 中的具体 Tile。
- **资源**：使用 16-tile 的 tileset (`dirt_tiles.png`, `grass_tiles.png`, etc.)。

## 3. 集成方案

### 3.1 渲染器设计
创建一个新的渲染器类 `DualGridDungeonRenderer`，负责地牢地形的渲染。

**主要职责**：
- 加载和管理 Tileset 资源。
- 接收 `Dungeon` 对象，根据 `TileType` 实时计算双网格 Mask。
- 绘制多层地形。

### 3.2 层级映射
地牢中的 `TileType` 将被映射到双网格的层级：

| 逻辑层级 | 对应 TileType | 使用 Tileset | 备注 |
| :--- | :--- | :--- | :--- |
| **Layer 0 (Base)** | All (默认背景) | `dirt_tiles.png` | 作为底层填充，避免黑边 |
| **Layer 1 (Sand)** | `Sand` | `sand_tiles.png` | 沙地层 |
| **Layer 2 (Grass)** | `Grass` | `grass_tiles.png` | 草地层 |
| **Layer 3 (Stone)** | `StonePath` | (需生成/加载) | 石板路 (可选) |

**注意**：`Wall`, `Door`, `Stairs` 等物体仍使用原有的单 Tile 渲染方式，叠加在地形层之上。

### 3.3 实时 Mask 计算
为了避免维护额外的数据结构，我们将直接在渲染循环中根据 `Dungeon` 的 `Tile` 数据计算 Mask。

算法：
对于每个渲染交点 (x, y)，检查周围四个 `Dungeon` 格子：
- `(x-1, y)`
- `(x, y)`
- `(x-1, y-1)`
- `(x, y-1)`

如果某个格子内的 `TileType` 与当前渲染层级匹配（例如正在渲染 Grass 层，且该格子是 Grass），则该位置记为 1，否则为 0。组合成 4-bit Mask。

### 3.4 坐标对齐
双网格渲染的是“交点”。
- 逻辑网格 (x, y) 的中心对应渲染坐标 `x * TILE_SIZE + OFFSET`。
- 我们需要调整偏移量，确保双网格地形与物体（Player, Items, Walls）对齐。
- 通常，双网格的 (x, y) 对应的是 `Dungeon` 格子 (x, y) 的**右下角**（或左上角，取决于实现）。
- Demo 中的实现：`drawX = x * TILE_SIZE - OFFSET`。OFFSET 是半个格子宽。这意味着 (x,y) 是格子的中心。
- 我们将保持这种对齐方式，确保 `Dungeon` 的格子中心与双网格的 Tile 中心一致。

## 4. 实施步骤

1.  **资源准备**：确保 `assets/sprites/tilesets/` 下的资源可用。
2.  **创建 `DualGridDungeonRenderer`**：实现上述逻辑。
3.  **修改 `GameScreen`**：
    - 初始化新渲染器。
    - 在 `draw()` 方法中，先调用 `DualGridDungeonRenderer.render()` 绘制地形。
    - 然后绘制 `Wall`, `Door`, `Stairs` 等非地形 Tile。
    - 最后绘制 Entity (Player, Monsters, Items)。

## 5. 后续优化
- 添加更多地形层（如水面）。
- 优化 Mask 计算性能（虽然对于 50x50 的网格，实时计算完全没问题）。
- 处理 `Wall` 的自动拼接（Autotiling），但这通常使用不同的技术（47-tile system）。
