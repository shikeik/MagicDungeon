# 联机模式设计方案

## 1. 概述
本方案旨在将《MagicDungeon2》从单机游戏改造为支持局域网（及公网转发）的多人联机游戏。核心目标是在保留地牢探索乐趣的基础上，增加多人协作与交互的体验，同时通过合理的架构设计保证开发的可维护性。

## 2. 核心机制

### 2.1 游戏暂停
*   **单人模式**：保留原有的暂停功能（打开背包、按 ESC 等）。
*   **多人模式**：
    *   **彻底取消世界暂停**。所有 UI 操作（背包、商店、技能树）均为实时进行，不阻断游戏逻辑。
    *   UI 设计需调整为半透明或非全屏遮挡，确保玩家在操作界面时能感知周围环境（如怪物袭击）。
    *   *设计意图：保持多人游戏的流畅性和紧张感，避免一人暂停全员罚站。*

### 2.2 资源分配
在创建房间时，房主可选择以下两种模式之一：

1.  **自由获取（Free for All）**
    *   **规则**：所有掉落物（怪物掉落、宝箱开启）对所有玩家可见且可拾取。
    *   **机制**：谁先点击拾取归谁（手快有，手慢无）。
    *   **适用场景**：熟人局、快节奏推图。

2.  **分配模式（Roll 点）**
    *   **普通掉落**：依旧采用自由获取模式。
    *   **稀有/BOSS 宝箱**：
        *   当开启 BOSS 宝箱或掉落史诗级以上装备时，触发 **Roll 点系统**。
        *   所有玩家屏幕出现 Roll 点界面（投掷 1-100 的骰子）。
        *   倒计时结束或所有人都投掷后，系统判定点数最大者获得该物品。
        *   **视觉效果**：Roll 点结束后，宝箱“喷发”出物品，并自动飞入获胜者的背包（或只有获胜者能拾取）。

### 2.3 过图机制（强制集合）
为避免多层地牢同时运行带来的性能开销和逻辑复杂性，采用**强制集合**机制：

*   **触发条件**：任意玩家站在“下一层入口（阶梯）”并进行交互。
*   **集合流程**：
    1.  触发后，所有玩家屏幕出现“前往下一层？”的倒计时投票弹窗（例如 10 秒）。
    2.  **同意**：玩家点击确认或自动倒计时结束（默认为同意）。
    3.  **拒绝**：任意玩家点击“拒绝/取消”，则倒计时立即中断，传送取消。
    4.  **传送**：若倒计时结束前无人拒绝，所有玩家同时传送至下一层初始位置。
*   *设计意图：确保团队行动一致性，避免掉队。*

## 3. 技术架构：Server-Client 模式

放弃 Host-Client（主机即客机）的混合逻辑，采用纯粹的 **Server-Client** 架构，以降低逻辑耦合度。

### 3.1 架构定义
*   **Server（服务端）**：
    *   负责所有游戏逻辑运算（怪物 AI、伤害计算、掉落生成、状态更新）。
    *   持有“权威”的游戏世界状态 (Authoritative State)。
    *   **Headless 运行**：不依赖任何图形界面库（LibGDX Headless），只处理数据。
*   **Client（客户端）**：
    *   负责渲染画面、播放音效、采集玩家输入。
    *   不进行任何核心逻辑判定（如“我打中了怪物”），只发送意图（如“我按下了攻击键”）。
    *   接收 Server 的状态快照并进行插值渲染。

### 3.2 玩家身份
*   **房主 (Host Player)**：
    *   **本地启动 Server 进程**（或在同一进程中开启 Server 线程）。
    *   **同时启动 Client 实例**，连接到本地 Server (`localhost`)。
    *   拥有 **Owner 权限**：只有房主的 Client 可以发送管理指令（如踢人、修改房间设置、重启关卡）。
*   **加入者 (Guest Player)**：
    *   只启动 Client 实例。
    *   通过 IP 地址（局域网 IP 或公网转发 IP）连接到房主的 Server。

## 4. 代码重构与技术挑战

为了实现上述架构，现有代码需要进行以下关键重构：

### 4.1 逻辑与视图分离 (Logic-View Separation)
目前 `GameScreen` 高度耦合了逻辑和渲染。
*   **现状**：`updateLogic()` 中直接混合了 `InputManager` 的检测和 `player.x += dx` 的位移。
*   **目标**：
    *   提取 **`GameWorld`** 类：包含 `Dungeon`, `List<Player>`, `List<Monster>`。只处理数据，不引用任何 `Texture` 或 `SpriteBatch`。
    *   `GameScreen` 退化为 **`GameRenderer`**：只负责根据 `GameWorld` 的数据画图。

### 4.2 实体系统改造
*   **多玩家支持**：将单例 `Player` 改造为 `Map<Integer, Player> players`，其中 `Integer` 为网络连接 ID (Connection ID)。
*   **输入抽象化**：
    *   本地输入不再直接控制角色。
    *   抽象为 **`Command`** (e.g., `MoveCommand`, `AttackCommand`)。
    *   Client: Input -> Command -> Network -> Server。
    *   Server: Receive Command -> Apply to World -> Broadcast State。

### 4.3 网络协议 (Protocol)
需要定义一套高效的通信协议（建议使用 KryoNet）：
*   **C2S (Client to Server)**: `LoginRequest`, `PlayerInputPacket` (包含按键状态或操作意图).
*   **S2C (Server to Client)**: 
    *   `WorldSnapshotPacket` (高频，包含所有实体位置、HP).
    *   `EventPacket` (低频，如“播放攻击音效”、“显示伤害数字”、“Roll点开始”).
    *   `MapDataPacket` (初始连接时发送地图种子或完整数据).

### 4.4 状态同步策略
*   **服务器权威**：一切以服务器为准。
*   **客户端预测 (Client Prediction)**：为了手感，Client 在按下移动键时可先行移动，收到 Server 纠正数据后再平滑修正（Reconciliation），避免高延迟下的顿挫感。

