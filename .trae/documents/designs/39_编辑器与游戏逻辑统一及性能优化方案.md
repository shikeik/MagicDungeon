# 编辑器与游戏逻辑统一及性能优化方案

## 1. 背景与目标
当前项目中，`CampEditorScreen`（营地编辑器）与 `GameScreen`（游戏主逻辑）存在严重的逻辑割裂。编辑器使用了一套独立的、基于 Hack（渲染代理）的实现方式，导致性能不佳且无法产出游戏可用的数据。用户希望编辑器制作的内容（如营地布局、特定地牢层）能被游戏直接加载使用，同时解决性能问题。

**主要目标**:
1.  **性能优化**: 消除编辑器中的渲染代理 Hack，优化多层地图的渲染性能。
2.  **逻辑统一**: 建立统一的地图数据标准，使编辑器产出的内容能被游戏核心逻辑识别和加载。
3.  **数据驱动**: 游戏中的营地（Camp）应优先加载编辑器生成的静态数据，而非纯代码生成。

## 2. 性能优化方案：渲染器解耦

### 现状分析
`CampEditorScreen` 目前通过创建一个假的 `Dungeon` 对象 (`renderProxy`)，并在每一帧渲染循环中多次修改其 `map` 引用来欺骗 `DualGridDungeonRenderer` 进行绘制。这种方式导致了大量的对象状态切换和潜在的 Batch 刷新，且逻辑极其脆弱。

### 解决方案
重构 `DualGridDungeonRenderer`，将其从“渲染一个 Dungeon 对象”转变为“渲染一份地图数据”。

**重构计划**:
1.  **提取核心渲染逻辑**: 将 `render(NeonBatch, Dungeon)` 方法拆解。
2.  **新增底层接口**: `renderMap(NeonBatch batch, Tile[][] map, DungeonTheme theme, boolean isCampMode)`。
3.  **编辑器适配**: 编辑器直接持有 `List<Tile[][]>`，并在渲染循环中直接调用底层接口渲染每一层，无需通过 `renderProxy` 中转。

## 3. 逻辑统一方案：地图数据标准

为了让游戏能加载编辑器的数据，我们需要定义一个通用的数据交换格式（JSON）。

### 3.1 数据结构定义 (`GameMapData`)

```java
public class GameMapData {
    public int width;
    public int height;
    public String themeName; // DungeonTheme
    
    // 地图数据：扁平化的 TileType 数组或二维数组
    // 考虑到 JSON 可读性，使用 int[][] 存储 TileType.ordinal() 或 String[][] 存储 name()
    // 推荐使用 String[][] 以保持版本兼容性（枚举顺序改变不影响）
    public String[][] grid; 
    
    // 实体列表
    public List<MapEntityData> entities;
    public List<MapItemData> items;
}

public class MapEntityData {
    public int x, y;
    public String type; // MonsterType.name()
}

public class MapItemData {
    public int x, y;
    public String itemId; // ItemData.name()
}
```

### 3.2 数据流向
1.  **编辑器 (CampEditorScreen)**:
    *   用户编辑地图、放置实体。
    *   点击“保存” -> 将当前层（或多层合并后的结果）序列化为 `camp.json`。
    *   保存路径: `assets/maps/camp.json` (作为内部资源) 或 `local/maps/` (作为用户自定义)。鉴于这是开发工具，暂定 `assets/maps/`。

2.  **游戏 (GameScreen / Dungeon)**:
    *   `Dungeon.generate()` 逻辑修改。
    *   当 `level == 0` (营地) 时，优先检查 `assets/maps/camp.json` 是否存在。
    *   若存在 -> 解析 JSON -> 填充 `this.map` -> 实例化实体列表。
    *   若不存在 -> 回退到 `CampMapGenerator` 代码生成。

## 4. 多层地图处理策略
编辑器支持多层编辑，但游戏核心 `Dungeon` 目前仅支持单层 `Tile[][]`。
为了不破坏游戏核心的高效性，我们在**导出阶段**处理多层逻辑：

*   **导出策略**: "Flatten" (压平)。
*   编辑器在保存时，从下到上遍历所有层，计算最终的 `Tile` 状态（类似 Photoshop 的 "合并可见图层"）。
*   游戏只读取合并后的单层数据。
*   *未来扩展*: 如果需要保留编辑能力，编辑器应保存一份 `.project` 源文件（含多层），同时导出一份 `.json` 游戏文件（单层）。本阶段简化处理，直接导出单层 JSON。

## 5. 实施步骤

1.  **Core 重构**: 修改 `DualGridDungeonRenderer`，添加 `renderTileGrid` 方法。
2.  **数据层实现**: 创建 `GameMapData` 及相关 POJO，实现 JSON 序列化/反序列化工具。
3.  **编辑器改造**:
    *   移除 `renderProxy`。
    *   使用新渲染接口。
    *   实现“保存”功能（导出 Flatten 后的 JSON）。
    *   实现“加载”功能（加载 JSON 到编辑器，反向解析）。
4.  **游戏侧接入**:
    *   修改 `Dungeon.generate()`，增加 JSON 加载分支。
    *   修改 `GameScreen`，确保从 `Dungeon` 获取实体数据并生成游戏对象。

## 6. 验证计划
1.  **编辑器验证**: 启动编辑器，绘制一个包含特殊地形（如特定的墙壁形状）和怪物（如 Boss）的营地，保存。
2.  **游戏验证**: 启动游戏，进入营地。检查地形是否与编辑器绘制一致，怪物是否出现在指定位置。
3.  **性能验证**: 检查编辑器帧率，确保移除 Hack 后渲染流畅。
