# NeonTextureGen 动态纹理生成系统设计

## 1. 概述
本项目旨在解决当前游戏中纹理资源分辨率硬编码（256x256）的问题。通过使用 `NeonBatch` 矢量绘图引擎，我们将实现基于 UV 坐标（0~1）的程序化纹理生成。这将允许我们在运行时生成任意分辨率（如 64x64, 128x128, 512x512）的清晰纹理，并支持无损缩放。

## 2. 核心设计：UV 坐标系统
为了实现分辨率无关，所有的绘制指令必须基于归一化的 UV 坐标，而不是绝对像素值。

*   **坐标空间**：`[0.0, 1.0]`
*   **原点**：左下角 `(0, 0)` （符合 LibGDX/OpenGL 标准）
*   **转换公式**：
    *   输入：目标尺寸 `size` (像素)
    *   绘制坐标：`x = u * size`, `y = v * size`, `w = uw * size`, `h = vh * size`

### 2.1 遗留数据转换 (Pixmap -> Neon)
现有的 `SpriteGenerator` 使用 `Pixmap` (左上角原点，Y轴向下)。迁移时需进行坐标翻转：
*   `Pixmap Rect(px, py, pw, ph)` (Top-Left)
*   `Neon Rect(u, v, uw, vh)` (Bottom-Left)
    *   `u = px / BASE_SIZE`
    *   `v = 1.0 - (py + ph) / BASE_SIZE`
    *   `uw = pw / BASE_SIZE`
    *   `vh = ph / BASE_SIZE`
*   `BASE_SIZE` 通常为 256。

## 3. 测试场景改进 (NeonGenTestScreen)
为了验证生成效果，我们将升级测试场景，提供更全面的预览功能。

### 3.1 UI 布局
*   **控制区 (左上角)**
    *   `Size`: [SmartNumInput] 生成纹理的目标分辨率 (例如 64, 128, 256)。修改后自动触发重绘。
    *   `Layout Scale`: [SmartNumInput] 预览面板的显示大小 (例如 300px)，用于控制屏幕上的显示区域，不影响生成内容的实际分辨率。

*   **展示区 (三栏布局)**
    1.  **Live Vector (实时矢量)**
        *   **内容**：直接调用 `NeonBatch` 绘制指令。
        *   **特点**：永远清晰，无锯齿。
        *   **用途**：验证绘制逻辑和几何形状是否正确。
        *   **显示**：拉伸填满预览面板。
    2.  **Texture Output (Stretch) (纹理输出-拉伸)**
        *   **内容**：`FrameBuffer` 捕获的纹理。
        *   **特点**：受分辨率影响，拉伸显示。
        *   **用途**：查看在游戏中被拉大时的模糊/像素化效果。
        *   **过滤**：Nearest (像素风) 或 Linear (平滑)，当前默认为 Nearest。
    3.  **Texture Output (Actual) (纹理输出-原大)**
        *   **内容**：`FrameBuffer` 捕获的纹理。
        *   **特点**：1:1 像素显示，不缩放，居中对齐。
        *   **用途**：查看 64x64 等小尺寸下的实际像素细节，确保像素艺术风格正确。

## 4. Player 绘制逻辑复刻 (UV版)
我们将复刻 `SpriteGenerator.createPlayer()` 的逻辑。以下是关键部件的转换映射 (基于 256x256 画布)：

| 部件 | Pixmap (x, y, w, h) | 描述 | Neon UV (u, v, uw, vh) | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| **Legs** | (90, 180, 25, 60) | 左腿 | (0.351, 0.062, 0.098, 0.234) | `v = 1 - (180+60)/256 = 16/256 = 0.0625` |
| **Boots** | (53, 215, 65, 45) | 左靴 | (0.207, -0.015, 0.254, 0.176) | 底部溢出修正：215+45=260 > 256，原图可能有截断或贴底 |
| **Head** | (90, 36, 76, 64) | 头部 | (0.351, 0.609, 0.297, 0.250) | `v = 1 - (36+64)/256 = 156/256` |
| **Body** | (70, 100, 116, 90) | 躯干 | (0.273, 0.258, 0.453, 0.352) | `v = 1 - (100+90)/256 = 66/256` |

*注意：原 Pixmap 逻辑中部分坐标 (如靴子 y=215, h=45 -> y_end=260) 超出了 256 范围，这在 NeonBatch 中会正确绘制（视口外裁切），但在 UV 计算时要注意不要产生负数或错误的相对关系，尽量保持原比例。*

## 5. 实现计划
1.  修改 `NeonGenTestScreen`，增加布局控制和三个预览面板。
2.  实现 `UVHelper` 工具类，简化 `(px, py, pw, ph) -> (u, v, uw, vh)` 的计算。
3.  编写 `drawPlayer(NeonBatch batch, float size)` 方法，替换掉原来的测试图形。
