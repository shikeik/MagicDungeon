# MagicDungeon2 联机系统版本报表
## 报表 13: v0.6.2~v0.6.3 Spawn自动派生与RPC双向调用机制报表

### 1. 简述
在 v0.6.1 完成了 NetBuffer 二进制序列化自动同步后，本轮迭代（v0.6.2 + v0.6.3）连续突破了两个关键系统层：
- **v0.6.2**: 实现了 Spawn 自动派生机制，彻底消除了测试和沙盒中的 Java 反射注入黑魔法。
- **v0.6.3**: 实现了完整的 RPC（远程过程调用）双向调用链路，并将沙盒中的子弹生成从内存直拷贝升级为通过 `@ClientRpc` 网络广播。

至此，Netcode 引擎的三大核心支柱——**状态同步 (NetworkVariable)**、**实体派生 (Spawn)**、**方法调用 (RPC)**——已全部落地。

---

### 2. v0.6.2 核心成果：Spawn 自动派生

#### 2.1 预制体工厂机制 (NetworkPrefabFactory)
引入了 `NetworkPrefabFactory` 接口，它是一个极简的函数式接口，负责在被调用时创建一个完整的 `NetworkObject`（含业务组件）。Server 和 Client 两端需要注册相同 `prefabId` 对应的工厂实例，从而保证双端能通过同一个 ID 创建出结构一致的实体。

#### 2.2 SpawnPacket 协议 (0x11)
在 `NetworkManager.spawnWithPrefab(prefabId)` 被调用时：
1. Server 端通过工厂创建本地实体，分配唯一的 `networkId`，注册到网络对象表。
2. 构建 SpawnPacket `[0x11][networkId][prefabId]` 并通过 Transport 广播。
3. Client 端 `onReceiveData()` 识别到 0x11 包头后，查找本地工厂，自动创建副本实体并注册。

#### 2.3 反射 Hack 全面清除
- `DualEndpointIntegrationTest` 不再使用 `getDeclaredField("networkObjects")` 强行注入。
- `NetcodeTankSandboxScreen` 删除了 `registerEntityInClientManager()` 整个反射方法。
- 整个项目中不再有任何注入式的 `setAccessible(true)` 黑魔法（仅保留引擎自身合法的反射扫描）。

#### 2.4 NetworkObject API 扩展
- 新增无参构造函数（用于工厂创建）
- 新增 `setNetworkId()`、`prefabId` 字段、`getBehaviours()` 公开方法

#### 2.5 TDD 测试
新增 `SpawnAutoDerivationTest`，包含 3 个测试用例：
- `testServerSpawnAutoDerivesToClient` — 基础自动派生
- `testSpawnedEntityInitialStateSync` — Spawn + 首帧状态同步联合验证
- `testMultiplePrefabSpawn` — 多实体独立派生

---

### 3. v0.6.3 核心成果：RPC 双向调用

#### 3.1 调用链路架构
实现了完整的 RPC 二进制封包-传输-解包-反射执行链路：

**封包格式**: `[packetType(0x20/0x21)][netId][behaviourIndex][methodNameLen][methodNameBytes][argCount][arg1TypeTag][arg1Value]...`

- **0x20 = ServerRpc**: Client 端调用 `sendServerRpc(methodName, args...)` → 序列化封包 → `transport.sendToServer()` → Server 端 `onReceiveData()` → `handleRpcPacket()` → 反射执行目标方法
- **0x21 = ClientRpc**: Server 端调用 `sendClientRpc(methodName, args...)` → 序列化封包 → `transport.broadcast()` → Client 端 `onReceiveData()` → `handleRpcPacket()` → 反射执行目标方法

#### 3.2 参数序列化支持
采用类型标签（TypeTag）机制：
| TypeTag | 类型 | 序列化方式 |
|---------|------|------------|
| 1 | int | writeInt / readInt |
| 2 | float | writeFloat / readFloat |
| 3 | boolean | writeBoolean / readBoolean |
| 4 | String | writeString / readString |

反射调用时会精确匹配原始类型（`int.class`, `float.class`）以确保 `getDeclaredMethod` 正确定位。

#### 3.3 NetworkBehaviour 新增 API
- `sendServerRpc(String methodName, Object... args)` — 业务层调用，向 Server 发送 RPC
- `sendClientRpc(String methodName, Object... args)` — 业务层调用，向所有 Client 广播 RPC
- 内部持有 `NetworkManager` 引用，在 Spawn 时自动绑定

#### 3.4 沙盒实战验证
`NetcodeTankSandboxScreen` 中的子弹系统做了重大升级：
- **之前**：子弹在 Server 端维护，Client 端每帧从 Server 端内存直接拷贝所有子弹对象（假同步）。
- **现在**：Server 端开火时调用 `tank.sendClientRpc("rpcSpawnBullet", bx, by, bvx, bvy, ownerId)`，Client 端 `TankBehaviour` 上的 `@ClientRpc rpcSpawnBullet(...)` 方法被自动触发，在本地创建子弹并独立模拟运动轨迹。
- 这完美体现了 RPC 的核心价值：**一次性瞬发事件不走状态同步，而通过方法调用广播，各端独立模拟**。

#### 3.5 TDD 测试
新增 `RpcInvocationTest`，包含 3 个测试用例：
- `testClientRpc_ServerToClient` — Server 调用 ClientRpc，验证 Client 端方法被执行
- `testServerRpc_ClientToServer` — Client 调用 ServerRpc，验证 Server 端方法被执行并参数匹配
- `testRpcWithMixedParamTypes` — 混合参数类型 (int, float, String) 的序列化/反序列化链路验证

---

### 4. 测试总览
全量 Netcode 测试套件 **31/31 通过**，包含：
- NetBufferTest (基础序列化)
- NetworkVariableTest (变量脏标记)
- NetworkObjectTest (对象管理)
- NetworkBehaviourReflectionTest (反射注册)
- NetworkManagerTest (管理器核心)
- DualEndpointIntegrationTest (双端集成)
- RpcMethodReflectionTest (RPC 扫描)
- SpawnAutoDerivationTest (自动派生) ← 新增
- RpcInvocationTest (RPC 调用链) ← 新增

### 5. 下一步计划
Netcode 引擎的核心三大支柱已全部就位。下一阶段将聚焦于：
1. **真实网络介质接入 (Netty/UDP)** — 将 `LocalMemoryTransport` 替换为真实 Socket 传输层，实现跨进程/跨公网联机
2. **Despawn 机制** — 实现实体销毁的网络广播与本地清理
3. **沙盒功能增强** — 利用已有的 Spawn + RPC + 状态同步在沙盒中实现更丰富的玩法验证
