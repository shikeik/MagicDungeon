# GDEngine Netcode 通用联机框架与内存网关验证报表

## 一、 框架状态与当前里程碑
在这一阶段，我们主要进行了 **GDEngine Netcode 联机框架的高层设计与内存级别（TDD 驱动）验证**。我们的核心目标是将业务逻辑完全剥离出底层的网络通信层（类似 Unity NGO 框架）。目前，框架的核心类 `NetworkManager`, `NetworkVariable`, `NetworkObject`, `NetworkBehaviour` 已通过了严苛的头部 TDD 测试。 

并且我们创建了 `LocalMemoryTransport` (内存模拟网络传输层)。目前已能够做到“两个实例在不经过真网络的情况下，完美模拟 Server 监听数据异变，打包成 byte[] 发送给 Client 的生命周期”。

---

## 二、 核心答疑：“基于假 Transport 搭建的上层逻辑，变更为真网络时是否能无缝过渡？”

使用者对目前“仅用内存假环境开发，未来转回真实的底层 `TestNetty` (UDP/TCP) 的过程是否复杂及可行”抱有疑问。
结论是：**不仅能够无痛平滑过渡，这本身也是依赖倒置（Dependency Inversion）设计模式下最标准的做法。**

原因如下详述：

### 1. 业务逻辑毫无感知 (完全解耦)
游戏层开发人员所写的所有类（例如以后的 `TankLogic extends NetworkBehaviour`），在使用时只负责修改内部的 `NetworkVariable<Float> x, y;`。只要数据有异动，就会被 `NetworkManager` 系统抓取。这一过程哪怕下层连的是蓝牙甚至红外，业务层都不需要修改任何一行代码。

### 2. Transport 接口的纯粹性
我们定义的 `Transport` 接口非常克制，只对外暴露最核心的操作指令：
- `startServer(int port)`
- `connect(String ip, int port)` 
- `sendToClient(int clientId, byte[] payload)`
- `broadcast(byte[] payload)`
- 回调：当网关收到包时触发 `onReceiveData(byte[] payload)`

### 3. 未来的真实替换方案（以引用的 TestNetty 为例）
目前项目中（在 `MagicDungeon2/core/build.gradle` 已经通过 jitpack 引入了你的库: `com.github.GoldSprite:TestNetty:0.8.0.2`）。当我们准备接入真网络时，仅需单独写一个实现类：

```java
// 未来即将编写的真实网关层
public class TestNettyTransport implements Transport {
    // 依赖于你原来写的库
    private goldsprite.myUdpNetty.starter.Server nettyServer;
    private NetworkManager manager;
    
    @Override
    public void startServer(int port) {
        // 核心包装：使用真框架
        nettyServer = new Server(port);
        // 配置收包回调：拿到字节流后直接转发给上级引擎
        nettyServer.setPacketCallback(packet -> {
            manager.onReceiveData(packet.getBytes()); 
        });
        nettyServer.start();
    }

    @Override
    public void broadcast(byte[] payload) {
        // 利用真正的 UDP 发送包
        nettyServer.broadcast(payload);
    }
    // ... 其他接口同理
}
```
**无缝切换！** 在游戏启动时，只要将注入的类从：
`manager.setTransport(new LocalMemoryTransport());` 
修改为：
`manager.setTransport(new TestNettyTransport());`
**整个联机系统即可瞬间从“虚拟本机互搏”转为“局域网/公网真刀真枪拼杀”。**

### 4. 为什么要坚持先用假环境 (TDD 模式)
在网关测试中，常引发各种报错：“空指针”、“多线程竞争导致的脏数据”、“粘包拆包”。
- 如果没有 `LocalMemoryTransport` 作为中介隔离：当接收端少一个血条数据时，我们不知道是底层“ UDP由于网络抖动不一定发送出去”丢包了，还是上层“脏检查管理器压根没扫到那个变更”。
- 为了**不让业务调试和物理传输调试彼此干扰**，我们利用在 `NetBufferTest` 与 `DualEndpointIntegrationTest` 里的假层，验证了：【只要 `byte[]` 不丢，上层的封装、组装、解包还原毫无问题】。

---

## 三、 下阶段推进计划 (坦克大战沙盒原型)
打通了内存连通性后，我们将按原定计划开始基于 LibGDX 执行**极简的同屏沙盒通信原型渲染**：
1. **建立小游戏场景**: 初始化基于 `NeonBatch` 或普通形状的渲染块来代表两台坦克。
2. **逻辑绑定**: 将坦克位置装入 `NetworkVariable<Float> x, y` 的逻辑载体中。
3. **建立假双端**: 游戏界面的左右两边分布着两个不同的游戏逻辑根，通过 `LocalMemoryTransport` 实现互相即时克隆位置数据。
4. **等待实装**: 当假双端游戏能在同一个屏幕里丝滑交互后，再正式按照上述第 3 点挂接 `TestNetty` 完成底层网络实装。
