# v0.4.1 版本报表 — 开始游戏广播链路修复

**日期**: 2026-03-01  
**版本**: 0.4.1  
**主题**: 修复房主"开始游戏"信号无法被客户端接收的问题 + 修复客户端收到信号后闪退

---

## BUG-1：客户端收不到开始游戏信号

### 问题描述

房主点击"开始游戏"后，自身可正常跳转到游戏屏，但所有客户端无反应，停留在大厅。

### 逻辑链追踪

```
房主点击按钮 → startGame() → broadcastGameStart()
  → 发送 BroadcastRequestPacket(CMD_GAME_START)     ← 发的包
  → 服务器框架 handleBroadcastRequestPacket() 自动包装消息
    原始: "$CMD:GAME_START"
    包装后: "<玩家-1-PlayerName>广播: $CMD:GAME_START"
  → 客户端收到 BroadcastResponsePacket
  → 订阅回调用 CMD_GAME_START.equals(msg) 精确匹配
    → 永远 false（因为消息被框架加了前缀）
    → 走进 else 分支，当作普通聊天消息
    → GAME_START 事件从未入队
    → consumeEvents() 中 GAME_START 判断从未命中
    → 客户端不跳转
```

### 根因

`broadcastGameStart()` 复用了框架内置的 `BroadcastRequestPacket`（聊天广播通道），但框架的 `handleBroadcastRequestPacket` 会自动拼接 `"<玩家-{guid}-{name}>广播: "` 前缀。客户端侧用 `equals` 精确匹配原始命令字符串，永远匹配不上。

而项目中已定义好的专用包类型 `LanGameStartRequestPacket`（cmd=45）和 `LanGameStartBroadcastPacket`（cmd=46）从未被使用。

### 修复方案

将 `broadcastGameStart()` 改为使用已有的专用包类型：

```
房主客户端
  → 发送 LanGameStartRequestPacket(cmd=45)
  → 服务器 onGameStartRequest() 遍历所有已登录客户端
    → 发送 LanGameStartBroadcastPacket(cmd=46) 给每个客户端
      → 客户端 subscriber 触发
        → eventQueue.offer(GAME_START)
          → consumeEvents() 匹配 Type.GAME_START
            → startGame() 跳转游戏屏
```

### 变更清单

| 改动点 | 修改前 | 修改后 |
|---|---|---|
| `broadcastGameStart()` | `new BroadcastRequestPacket(localGuid, CMD_GAME_START)` | `new LanGameStartRequestPacket(localGuid)` |
| `CMD_GAME_START` 常量 | 存在 | 已删除 |
| `BroadcastResponsePacket` 订阅 | 内含命令字符串判断分支 | 仅处理聊天消息 |
| `LanGameStartBroadcastPacket` 订阅 | 注释为"备用" | 唯一的 GAME_START 事件来源 |

---

## BUG-2：客户端收到开始信号后闪退（NullPointerException）

### 问题描述

修复 BUG-1 后，客户端能收到开始游戏信号，但瞬间闪退。房主正常。

### 逻辑链追踪

```
客户端 render0() 每帧执行:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
if (!startingGame && lanService != null) {   ← 进入 if 块时条件成立
│
│  consumeEvents();
│  │
│  └→ 检测到 GAME_START 事件
│     └→ startGame()
│        ├→ startingGame = true
│        ├→ this.lanService = null  ← ⚠️ lanService 被置空！
│        └→ return  (退出 consumeEvents)
│
│  ┌─── consumeEvents() 返回后，继续执行 if 块内的后续代码 ───┐
│  │                                                         │
│  if (lanService.isConnected()) {  ← 💥 NullPointerException！
│       lanService 已经是 null 了！
│  }
│
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 为什么房主不会崩溃

```
房主流程:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 用户点击按钮 → ClickListener 直接调用 startGame()
   ├→ startingGame = true
   └→ this.lanService = null

2. 下一帧 render0():
   if (!startingGame && ...)  ← startingGame 已经是 true
       整个 if 块被跳过      ← 安全，不会访问 lanService
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

关键区别：
- **房主**：`startGame()` 从按钮回调触发（在 `render0` 的 if 块**外部**），下一帧 if 条件直接跳过
- **客户端**：`startGame()` 从 `consumeEvents()` 触发（在 `render0` 的 if 块**内部**），return 后控制流仍在 if 块内继续执行

### 修复方案

在 `consumeEvents()` 返回后，重新检查 `startingGame` 和 `lanService` 的状态：

```java
if (!startingGame && lanService != null) {
    consumeEvents();

    // consumeEvents() 内部可能触发 startGame()，导致 lanService 被置 null，需要重新检查
    if (startingGame || lanService == null) {
        // 已进入转场流程，跳过后续网络操作
    } else {
        // ... 原有的刷新/检测逻辑
    }
}
```

---

## 涉及文件

| 文件 | 变更类型 |
|---|---|
| `core/.../network/lan/LanMultiplayerService.java` | BUG-1: 修复发包通道 + 清理命令字符串逻辑 |
| `examples/.../screens/main/LanLobbyScreen.java` | BUG-2: consumeEvents 后增加状态重检 |

---

## 联机架构说明（当前项目）

### 角色关系

项目采用 **"房主 = Server + Client"** 模型：

```
┌─────────────────────────────────────────────┐
│              房主玩家的进程                    │
│                                             │
│  ┌─────────┐       ┌─────────┐              │
│  │ Server  │◄─────►│ Client  │ (自连接)      │
│  │ (中转)   │       │ guid=0  │              │
│  └────┬────┘       └─────────┘              │
│       │                                     │
└───────┼─────────────────────────────────────┘
        │ UDP
        │
┌───────┼──────┐    ┌──────────────┐
│  Client      │    │  Client      │
│  guid=1      │    │  guid=2      │
│  (普通成员)   │    │  (普通成员)   │
└──────────────┘    └──────────────┘
```

### 各角色职责

| 概念 | 实际含义 | 代码对应 |
|---|---|---|
| **Server** | 纯中转/转发层，运行在房主进程内，无游戏逻辑 | `Server` 实例 + `registerServerSubscribers()` |
| **Client** | 所有玩家（包括房主）的统一身份，通过 Client 收发包 | `Client` 实例 + `registerPacketSubscribers()` |
| **房主 (Host)** | 只是一个标识（`Mode.HOST`），表示"我同时启动了 Server" | `startHost()` 中先启 Server 再启 Client |
| **成员** | 纯 Client，连接到房主进程中的 Server | `join()` 中只启 Client |

### 关键设计原则

**不存在第三种角色**。代码中 `Mode.HOST` 和 `Mode.CLIENT` 的区别仅在于：

- `HOST`：`startHost()` 额外启动了一个 Server 实例，其余所有逻辑（登录、收发包、同步）走的都是 Client 通道，与普通成员完全一致
- `CLIENT`：只启动 Client，连接到远端 Server

房主的 Client 和普通成员的 Client 走**完全相同的代码路径**（`startClientInternal` / `registerPacketSubscribers`），Server 只做无脑中转。

### 当前 Mode 的实际用途

`Mode` 枚举目前只在以下两处产生行为差异：

1. **UI层**：决定是否显示"开始游戏"按钮（仅房主可见）
2. **startGame()**：房主需要额外广播开始信号，客户端不需要

在网络收发层面，`HOST` 和 `CLIENT` 的行为完全一致，不存在三方逻辑。

---

## 验证要点

- [ ] 房主创建房间后，客户端加入，双方在成员列表中互相可见
- [ ] 房主点击"开始游戏"，自身和所有客户端均跳转到 `SimpleGameScreen`
- [ ] 客户端日志中出现 `[GAME_START] 房主已开始游戏！`
- [ ] 客户端收到信号后不闪退
- [ ] 普通聊天广播不受影响
