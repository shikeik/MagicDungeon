# v0.4.1 版本报表 — 开始游戏广播链路修复

**日期**: 2026-03-01  
**版本**: 0.4.1  
**主题**: 修复房主"开始游戏"信号无法被客户端接收的问题 + 联机链路架构澄清

---

## 问题描述

房主点击"开始游戏"后，自身可正常跳转到游戏屏，但所有客户端无反应，停留在大厅。

## 根因分析

### 逻辑链追踪

```
房主点击按钮 → startGame() → broadcastGameStart()
  → 发送 BroadcastRequestPacket(CMD_GAME_START)     ← 发的包
  → 服务器框架 handleBroadcastRequestPacket() 自动包装消息
    原始: "$CMD:GAME_START"
    包装后: "<玩家-1-PlayerName>广播: $CMD:GAME_START"
  → 客户端收到 BroadcastResponsePacket
  → 订阅回调用 CMD_GAME_START.equals(msg) 精确匹配
    → 永远 false（因为消息被框架加了前缀）
    → 走进 else 分支，当作普通聊天消息
    → GAME_START 事件从未入队
    → consumeEvents() 中 GAME_START 判断从未命中
    → 客户端不跳转
```

### 核心矛盾

`broadcastGameStart()` 复用了框架内置的 `BroadcastRequestPacket`（聊天广播通道），但框架的 `handleBroadcastRequestPacket` 会自动拼接 `"<玩家-{guid}-{name}>广播: "` 前缀。客户端侧用 `equals` 精确匹配原始命令字符串，永远匹配不上。

而项目中已定义好的专用包类型 `LanGameStartRequestPacket`（cmd=45）和 `LanGameStartBroadcastPacket`（cmd=46）从未被使用。

## 修复方案

将 `broadcastGameStart()` 从复用聊天广播通道，改为使用已有的专用包类型，完整链路跑通：

```
房主客户端
  → 发送 LanGameStartRequestPacket(cmd=45)
  → 服务器 onGameStartRequest() 遍历所有已登录客户端
    → 发送 LanGameStartBroadcastPacket(cmd=46) 给每个客户端
      → 客户端 subscriber 触发
        → eventQueue.offer(GAME_START)
          → consumeEvents() 匹配 Type.GAME_START
            → startGame() 跳转游戏屏
```

## 变更清单

### LanMultiplayerService.java

| 改动点 | 修改前 | 修改后 |
|---|---|---|
| `broadcastGameStart()` | `client.sendPacket(new BroadcastRequestPacket(localGuid, CMD_GAME_START))` | `client.sendPacket(new LanGameStartRequestPacket(localGuid))` |
| `CMD_GAME_START` 常量 | 存在 | 已删除（不再需要） |
| `BroadcastResponsePacket` 订阅 | 内含 `CMD_GAME_START.equals(msg)` 命令判断分支 | 仅处理聊天消息 |
| `LanGameStartBroadcastPacket` 订阅 | 注释为"备用" | 改为唯一的 GAME_START 事件来源 |

## 涉及文件

| 文件 | 变更类型 |
|---|---|
| `core/.../network/lan/LanMultiplayerService.java` | 修复发包通道 + 清理命令字符串逻辑 |

已有文件无需新增或删除。

---

## 联机架构说明（当前项目）

### 角色关系

项目采用 **"房主 = Server + Client"** 模型：

```
┌─────────────────────────────────────────────┐
│              房主玩家的进程                    │
│                                             │
│  ┌─────────┐       ┌─────────┐              │
│  │ Server  │◄─────►│ Client  │ (自连接)      │
│  │ (中转)   │       │ guid=0  │              │
│  └────┬────┘       └─────────┘              │
│       │                                     │
└───────┼─────────────────────────────────────┘
        │ UDP
        │
┌───────┼──────┐    ┌──────────────┐
│  Client      │    │  Client      │
│  guid=1      │    │  guid=2      │
│  (普通成员)   │    │  (普通成员)   │
└──────────────┘    └──────────────┘
```

### 各角色职责

| 概念 | 实际含义 | 代码对应 |
|---|---|---|
| **Server** | 纯中转/转发层，运行在房主进程内，无游戏逻辑 | `Server` 实例 + `registerServerSubscribers()` |
| **Client** | 所有玩家（包括房主）的统一身份，通过 Client 收发包 | `Client` 实例 + `registerPacketSubscribers()` |
| **房主 (Host)** | 只是一个标识（`Mode.HOST`），表示"我同时启动了 Server" | `startHost()` 中先启 Server 再启 Client |
| **成员** | 纯 Client，连接到房主进程中的 Server | `join()` 中只启 Client |

### 关键设计原则

**不存在第三种角色**。代码中 `Mode.HOST` 和 `Mode.CLIENT` 的区别仅在于：

- `HOST`：`startHost()` 额外启动了一个 Server 实例，其余所有逻辑（登录、收发包、同步）走的都是 Client 通道，与普通成员完全一致
- `CLIENT`：只启动 Client，连接到远端 Server

房主的 Client 和普通成员的 Client 走**完全相同的代码路径**（`startClientInternal` / `registerPacketSubscribers`），Server 只做无脑中转。

### 当前 Mode 的实际用途

`Mode` 枚举目前只在 UI 层用于判断是否显示"开始游戏"按钮：

```java
// LanLobbyScreen.java
startBtn.setVisible(phase == Phase.HOST_WAITING);  // 仅房主可见
```

以及 `startGame()` 中决定是否需要广播开始信号：

```java
if (phase == Phase.HOST_WAITING && lanService != null) {
    lanService.broadcastGameStart();  // 房主才广播
}
```

在网络收发层面，`HOST` 和 `CLIENT` 的行为完全一致，不存在三方逻辑。

---

## 验证要点

- [ ] 房主创建房间后，客户端加入，双方在成员列表中互相可见
- [ ] 房主点击"开始游戏"，自身和所有客户端均跳转到 `SimpleGameScreen`
- [ ] 客户端日志中出现 `[GAME_START] 房主已开始游戏！`
- [ ] 普通聊天广播不受影响
