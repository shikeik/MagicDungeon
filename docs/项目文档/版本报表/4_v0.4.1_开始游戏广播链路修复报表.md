# v0.4.1 版本报表 — 开始游戏广播链路修复

**日期**: 2026-03-01  
**版本**: 0.4.1  
**主题**: 修复房主"开始游戏"信号无法被客户端接收的问题 + 修复客户端收到信号后闪退

---

## BUG-1：客户端收不到开始游戏信号

### 问题描述

房主点击"开始游戏"后，自身可正常跳转到游戏屏，但所有客户端无反应，停留在大厅。

### 逻辑链追踪

```
房主点击按钮 → startGame() → broadcastGameStart()
  → 发送 BroadcastRequestPacket(CMD_GAME_START)     ← 发的包
  → 服务器框架 handleBroadcastRequestPacket() 自动包装消息
    原始: "$CMD:GAME_START"
    包装后: "<玩家-1-PlayerName>广播: $CMD:GAME_START"
  → 客户端收到 BroadcastResponsePacket
  → 订阅回调用 CMD_GAME_START.equals(msg) 精确匹配
    → 永远 false（因为消息被框架加了前缀）
    → 走进 else 分支，当作普通聊天消息
    → GAME_START 事件从未入队
    → consumeEvents() 中 GAME_START 判断从未命中
    → 客户端不跳转
```

### 根因

`broadcastGameStart()` 复用了框架内置的 `BroadcastRequestPacket`（聊天广播通道），但框架的 `handleBroadcastRequestPacket` 会自动拼接 `"<玩家-{guid}-{name}>广播: "` 前缀。客户端侧用 `equals` 精确匹配原始命令字符串，永远匹配不上。

而项目中已定义好的专用包类型 `LanGameStartRequestPacket`（cmd=45）和 `LanGameStartBroadcastPacket`（cmd=46）从未被使用。

### 修复方案

将 `broadcastGameStart()` 改为使用已有的专用包类型：

```
房主客户端
  → 发送 LanGameStartRequestPacket(cmd=45)
  → 服务器 onGameStartRequest() 遍历所有已登录客户端
    → 发送 LanGameStartBroadcastPacket(cmd=46) 给每个客户端
      → 客户端 subscriber 触发
        → eventQueue.offer(GAME_START)
          → consumeEvents() 匹配 Type.GAME_START
            → startGame() 跳转游戏屏
```

### 变更清单

| 改动点 | 修改前 | 修改后 |
|---|---|---|
| `broadcastGameStart()` | `new BroadcastRequestPacket(localGuid, CMD_GAME_START)` | `new LanGameStartRequestPacket(localGuid)` |
| `CMD_GAME_START` 常量 | 存在 | 已删除 |
| `BroadcastResponsePacket` 订阅 | 内含命令字符串判断分支 | 仅处理聊天消息 |
| `LanGameStartBroadcastPacket` 订阅 | 注释为"备用" | 唯一的 GAME_START 事件来源 |

---

## BUG-2：客户端收到开始信号后闪退（NullPointerException）

### 问题描述

修复 BUG-1 后，客户端能收到开始游戏信号，但瞬间闪退。房主正常。

### 逻辑链追踪

```
客户端 render0() 每帧执行:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
if (!startingGame && lanService != null) {   ← 进入 if 块时条件成立
│
│  consumeEvents();
│  │
│  └→ 检测到 GAME_START 事件
│     └→ startGame()
│        ├→ startingGame = true
│        ├→ this.lanService = null  ← ⚠️ lanService 被置空！
│        └→ return  (退出 consumeEvents)
│
│  ┌─── consumeEvents() 返回后，继续执行 if 块内的后续代码 ───┐
│  │                                                         │
│  if (lanService.isConnected()) {  ← 💥 NullPointerException！
│       lanService 已经是 null 了！
│  }
│
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 为什么房主不会崩溃

```
房主流程:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 用户点击按钮 → ClickListener 直接调用 startGame()
   ├→ startingGame = true
   └→ this.lanService = null

2. 下一帧 render0():
   if (!startingGame && ...)  ← startingGame 已经是 true
       整个 if 块被跳过      ← 安全，不会访问 lanService
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

关键区别：
- **房主**：`startGame()` 从按钮回调触发（在 `render0` 的 if 块**外部**），下一帧 if 条件直接跳过
- **客户端**：`startGame()` 从 `consumeEvents()` 触发（在 `render0` 的 if 块**内部**），return 后控制流仍在 if 块内继续执行

### 修复方案

在 `consumeEvents()` 返回后，重新检查 `startingGame` 和 `lanService` 的状态：

```java
if (!startingGame && lanService != null) {
    consumeEvents();

    // consumeEvents() 内部可能触发 startGame()，导致 lanService 被置 null，需要重新检查
    if (startingGame || lanService == null) {
        // 已进入转场流程，跳过后续网络操作
    } else {
        // ... 原有的刷新/检测逻辑
    }
}
```

---

## 涉及文件

| 文件 | 变更类型 |
|---|---|
| `core/.../network/lan/LanMultiplayerService.java` | BUG-1: 修复发包通道 + 清理命令字符串逻辑 |
| `examples/.../screens/main/LanLobbyScreen.java` | BUG-2: consumeEvents 后增加状态重检 |

---

## 联机架构说明（当前项目）

### 角色关系

项目采用 **"房主 = Server + Client"** 模型：

```
┌─────────────────────────────────────────────┐
│              房主玩家的进程                    │
│                                             │
│  ┌─────────┐       ┌─────────┐              │
│  │ Server  │◄─────►│ Client  │ (自连接)      │
│  │ (中转)   │       │ guid=0  │              │
│  └────┬────┘       └─────────┘              │
│       │                                     │
└───────┼─────────────────────────────────────┘
        │ UDP
        │
┌───────┼──────┐    ┌──────────────┐
│  Client      │    │  Client      │
│  guid=1      │    │  guid=2      │
│  (普通成员)   │    │  (普通成员)   │
└──────────────┘    └──────────────┘
```

### 各角色职责

| 概念 | 实际含义 | 代码对应 |
|---|---|---|
| **Server** | 纯中转/转发层，运行在房主进程内，无游戏逻辑 | `Server` 实例 + `registerServerSubscribers()` |
| **Client** | 所有玩家（包括房主）的统一身份，通过 Client 收发包 | `Client` 实例 + `registerPacketSubscribers()` |
| **房主 (Host)** | 只是一个标识（`Mode.HOST`），表示"我同时启动了 Server" | `startHost()` 中先启 Server 再启 Client |
| **成员** | 纯 Client，连接到房主进程中的 Server | `join()` 中只启 Client |

### 关键设计原则

**不存在第三种角色**。代码中 `Mode.HOST` 和 `Mode.CLIENT` 的区别仅在于：

- `HOST`：`startHost()` 额外启动了一个 Server 实例，其余所有逻辑（登录、收发包、同步）走的都是 Client 通道，与普通成员完全一致
- `CLIENT`：只启动 Client，连接到远端 Server

房主的 Client 和普通成员的 Client 走**完全相同的代码路径**（`startClientInternal` / `registerPacketSubscribers`），Server 只做无脑中转。

### 当前 Mode 的实际用途

`Mode` 枚举目前只在以下两处产生行为差异：

1. **UI层**：决定是否显示"开始游戏"按钮（仅房主可见）
2. **startGame()**：房主需要额外广播开始信号，客户端不需要

在网络收发层面，`HOST` 和 `CLIENT` 的行为完全一致，不存在三方逻辑。

---

## BUG-3：客户端闪退 + 房主卡死无响应

### 问题描述

修复 BUG-1 和 BUG-2 后，房主点击"开始游戏"：客户端闪退，房主卡死不再响应任何操作。

### 根因：`playOverlayFade` 被误用于跨屏幕切换

项目中 ScreenManager 提供两种转场 API：

| 方法 | 执行时机 | 设计用途 |
|---|---|---|
| `playTransition(onMiddle)` | **延迟到 FADE_OUT 动画完成(全黑)后**才执行 onMiddle | 跨屏幕切换(goScreen) |
| `playOverlayFade(action)` | **立即同步执行** action，然后从全黑渐隐 | 同屏轻量操作(如重建地图) |

`startGame()` 使用了 `playOverlayFade`，在 action 内调用 `goScreen()` —— 这意味着 **在当前帧的 render 循环中途，`curScreen` 被强行切换**。

### 房主卡死的执行流

```
LanLobbyScreen.render0(delta)
│
├─ stage.act(delta)                           ← 处理 UI 事件队列
│  └─ ClickListener 触发 startGame()
│     ├─ startingGame = true
│     ├─ broadcastGameStart()                 ← 异步发包, 立即返回
│     ├─ this.lanService = null               ← ⚠️ 提前置空
│     └─ playOverlayFade(action, 0.5f)
│        └─ action.run()                      ← 立即执行！
│           ├─ new SimpleGameScreen(service)
│           └─ goScreen(gameScreen)
│              ├─ _initializeScreen → create()
│              │   └─ 如果此处抛异常 → 💥
│              │      playOverlayFade 不会设 transitionState
│              │      但 startingGame=true, lanService=null 已执行
│              │      → 大厅卡在无效状态 = 永久卡死
│              ├─ curScreen.hide()             ← 大厅被隐藏
│              ├─ curScreen = gameScreen       ← curScreen 被换了
│              └─ gameScreen.show()
│
├─ stage.draw()  ← 还在画大厅的 stage！但 curScreen 已是 gameScreen
│
└─ return → ScreenManager.render()
   └─ renderTransition(delta)
      └─ curScreen 指向 SimpleGameScreen
         但其 UIViewport 可能还未 apply()
```

**关键问题链**：
1. `this.lanService = null` 在 `playOverlayFade` **之前**执行 → 即使 action 失败/抛异常, lanService 也已丢失
2. `SimpleGameScreen.create()` 若抛异常 → `transitionState` 永远不会被设为 `OVERLAY_FADE`
3. `startingGame = true` + `lanService = null` → 大厅的 if 块永远被跳过 → 无法更新网络、无法响应操作 → **卡死**

### 客户端闪退的执行流

```
LanLobbyScreen.render0(delta)
│
├─ if (!startingGame && lanService != null)
│  └─ consumeEvents()
│     └─ 检测到 GAME_START → startGame()
│        ├─ this.lanService = null
│        └─ playOverlayFade(action)
│           └─ action.run()                   ← 立即执行
│              └─ goScreen(gameScreen)
│                 └─ SimpleGameScreen.create()
│                    └─ 💥 若抛异常 → 直接穿透到 render0
│                       → 穿透到 ScreenManager.render
│                       → 未被 catch → 应用崩溃
```

### 修复方案

将 `playOverlayFade` 改为 `playTransition`，让 `goScreen` **延迟到遮罩完全变黑后**再执行：

```java
// 修复前（立即执行，导致 render 中途切换屏幕）
final LanMultiplayerService service = this.lanService;
this.lanService = null;  // ⚠️ 提前置空
getScreenManager().playOverlayFade(() -> {
    SimpleGameScreen gameScreen = new SimpleGameScreen(service);
    getScreenManager().goScreen(gameScreen);
}, 0.5f);

// 修复后（延迟到黑幕完全不透明后再执行）
getScreenManager().playTransition(() -> {
    final LanMultiplayerService service = this.lanService;
    this.lanService = null;  // 在安全时机移交所有权
    SimpleGameScreen gameScreen = new SimpleGameScreen(service);
    getScreenManager().goScreen(gameScreen);
});
```

**修复要点**：
- `goScreen()` 延迟到 `renderTransition()` 中 FADE_OUT 完成后执行，不会在 render0 中途切换 curScreen
- `lanService = null` 也移入回调，确保只在真正转场时才移交所有权
- 即使 `SimpleGameScreen.create()` 抛异常，也发生在 `renderTransition` 的受控时间点，不会导致大厅卡在无效状态

### 变更清单

| 改动点 | 修改前 | 修改后 |
|---|---|---|
| 转场 API | `playOverlayFade(action, 0.5f)` | `playTransition(action)` |
| `lanService = null` 时机 | 在 action 之前(不安全) | 在 action 回调内(安全) |
| `goScreen()` 执行时机 | 当前帧 render 中途(立即) | 下一帧 FADE_OUT 完成后(延迟) |

---

## 涉及文件（BUG-1 ~ BUG-3 汇总）

| 文件 | 变更类型 |
|---|---|
| `core/.../network/lan/LanMultiplayerService.java` | BUG-1: 修复发包通道 + 清理命令字符串逻辑 |
| `examples/.../screens/main/LanLobbyScreen.java` | BUG-2: consumeEvents 后增加状态重检 |
| `examples/.../screens/main/LanLobbyScreen.java` | BUG-3: startGame() 改用 playTransition + lanService 延迟置空 |

---

## 单机逻辑与联机逻辑架构分析

### 核心结论：一套代码，联机为可选扩展层

项目**不是**两套独立代码。`SimpleGameScreen` 是唯一的游戏场景类，同时承载单机和联机两种模式。通过 `lanService == null` 判断当前是否处于联机模式。

### 代码结构对比

```
SimpleGameScreen 每帧 render0(delta) 流程:
┌──────────────────────────────────────────────────────────┐
│  ScreenUtils.clear()                                     │
│                                                          │
│  virtualControls.update(delta)                           │ ← 通用输入
│                                                          │
│  if (player.alive) {                                     │
│    gameTime += delta                                     │
│    updatePlayer(delta)      ← 🎮 单机核心：移动/攻击/冷却 │
│    enemyAI.update(delta)    ← 🎮 单机核心：敌人AI         │
│    player.mp 回复           ← 🎮 单机核心：MP自然回复      │
│  }                                                       │
│                                                          │
│  // 视觉插值（通用）                                       │
│  player.updateVisuals(delta)                             │
│  enemies[i].updateVisuals(delta)                         │
│                                                          │
│  updateLan(delta)           ← 🌐 联机扩展：内部自检null    │
│                                                          │
│  renderer.updatePopups(delta)                            │
│  ... 以下全是渲染代码（通用）                               │
└──────────────────────────────────────────────────────────┘
```

### 联机层工作方式

`updateLan(delta)` 是联机逻辑的**唯一入口**，内部首先检查 `if (lanService == null || !lanService.isConnected()) return;`，单机模式下整个方法直接跳过。

```
updateLan(delta):
┌──────────────────────────────────────────────────┐
│ if (lanService == null) return;  ← 单机直接跳过   │
│                                                  │
│ ① 消费网络事件                                     │
│   drainEvents() → CHAT → 追加到 logText           │
│                → INFO → 追加到 logText            │
│                → GAME_START → (在游戏屏内被忽略)    │
│                                                  │
│ ② 发送本地状态（每 50ms 一次）                      │
│   sendLocalState(x, y, visualX, visualY, "idle") │
│                                                  │
│ ③ 更新远程玩家                                     │
│   lanService.getRemotePlayers()                  │
│   → 遍历 LanRoomPlayer 列表                      │
│   → 为每个远程玩家维护 GameEntity                   │
│   → 视觉坐标用 Lerp 平滑插值                       │
│   → 写入 remotePlayers 数组                       │
└──────────────────────────────────────────────────┘
```

### 联机具体同步了哪些内容

#### 已同步的字段

| 字段 | 类型 | 说明 |
|---|---|---|
| `x` | float | 逻辑格子坐标 X |
| `y` | float | 逻辑格子坐标 Y |
| `vx` (visualX) | float | 视觉像素坐标 X（用于渲染插值） |
| `vy` (visualY) | float | 视觉像素坐标 Y（用于渲染插值） |
| `action` | String | 动作标识（当前固定为 "idle"） |
| `timestamp` | long | 时间戳（用于 NetworkTransform 插值排序） |
| `playerGuid` | int | 玩家唯一标识 |
| `playerName` | String | 玩家名称 |

#### 未同步的内容（各客户端独立）

| 内容 | 说明 |
|---|---|
| 地图 `int[][] map` | 各客户端独立生成（相同算法但无同步种子 → 地图不同） |
| 敌人 `enemies` | 各客户端独立生成和AI计算，互不相关 |
| 战斗/伤害 | 攻击、受伤、击杀完全本地计算 |
| 成长/经验/等级 | 各客户端独立计算 |
| HP / MP / 属性 | 不同步 |
| 楼梯/换层 | 各客户端独立触发 |
| 死亡/重生 | 本地处理 |

### 同步质量评估

| 评估维度 | 当前状态 | 等级 |
|---|---|---|
| **同步频率** | 50ms (20Hz)，可配置 | ✅ 合理 |
| **插值平滑** | 客户端侧 Lerp 插值 (`* 10f * delta`) | ✅ 基本可用 |
| **NetworkTransform** | 已实现带延迟的快照插值(80ms delay) | ⚠️ 已编写但未在 SimpleGameScreen 中使用 |
| **协议注册** | 6个自定义包类型全部注册 | ✅ 完整 |
| **线程安全** | `ConcurrentHashMap` + `ConcurrentLinkedQueue` | ✅ 安全 |

### 当前同步模型的局限性

**本质：这是一个"位置可见"同步，不是"游戏状态"同步。**

```
当前模型:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
           玩家A (房主)
   ┌──────────────────────┐
   │ 自己的地图 + 自己的敌人 │ ← 完全独立的游戏世界
   │ 能看到玩家B的位置图标   │ ← 唯一的联机表现
   └──────────────────────┘
           玩家B (客户端)
   ┌──────────────────────┐
   │ 自己的地图 + 自己的敌人 │ ← 完全独立的游戏世界
   │ 能看到玩家A的位置图标   │ ← 唯一的联机表现
   └──────────────────────┘
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

效果：多人能看到彼此在"各自的地图上"走动，但由于地图/敌人各自独立生成、战斗各自独立计算，实际上是"各玩各的 + 能看到对方的影子"。

### 进化路线（如需真正的联机协作）

```
当前 → Phase 1 → Phase 2 → Phase 3
位置可见   地图统一   战斗同步   完整状态同步
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 ✅完成    需同步种子  需服务端    需权威服务器
           或房主广播  判定伤害    完整游戏逻辑
           地图数据    广播结果    只发送输入
```

---

## 验证要点

- [ ] 房主创建房间后，客户端加入，双方在成员列表中互相可见
- [ ] 房主点击"开始游戏"，自身和所有客户端均跳转到 `SimpleGameScreen`
- [ ] 客户端日志中出现 `[GAME_START] 房主已开始游戏！`
- [ ] 客户端收到信号后不闪退
- [ ] 房主点击"开始游戏"后不卡死
- [ ] 普通聊天广播不受影响
- [ ] 游戏中双方可看到对方的位置图标
