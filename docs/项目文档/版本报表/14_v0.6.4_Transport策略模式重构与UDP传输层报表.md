# MagicDungeon2 联机系统版本报表
## 报表 14: v0.6.4 Transport策略模式重构与UDP真实传输层报表

### 1. 简述
在 v0.6.3 完成了三大核心支柱（状态同步 / Spawn自动派生 / RPC双向调用）之后，本轮迭代聚焦于一个关键的架构问题：**引入真实网络传输层后，现有的单元测试还能不能继续用内存传输来跑？**

答案是：**完全可以。** 通过对 `Transport` 接口的策略模式重构，实现了传输层的热插拔能力——`LocalMemoryTransport`（测试用）和 `UdpSocketTransport`（真实网络用）可自由切换，现有全部测试零改动通过。

---

### 2. 架构重构：统一回调机制

#### 2.1 问题：耦合的接收回调
旧架构中，`LocalMemoryTransport` 内部直接持有 `NetworkManager` 引用，通过私有的 `setManager()` 方法手动接线。这导致：
- `setManager()` 不在 `Transport` 接口上，新传输层无法复用
- 每次搭建网络环境需要 2 行手动接线代码（`transport.setManager()` + `manager.setTransport()`）
- 违反了开闭原则

#### 2.2 解决方案：TransportReceiveCallback
引入 `TransportReceiveCallback` 函数式接口，在 `Transport` 接口上新增 `setReceiveCallback()` 方法：

```
Transport 接口
├── startServer(port)
├── connect(ip, port)
├── disconnect()
├── sendToClient(clientId, payload)
├── sendToServer(payload)
├── broadcast(payload)
├── isServer() / isClient()
└── setReceiveCallback(callback)  ← 新增
```

#### 2.3 自动接线
`NetworkManager.setTransport()` 内部自动调用 `transport.setReceiveCallback(this::onReceiveData)`，**一行代码完成双向绑定**，外部不再需要手动 `setManager()`。

所有测试和沙盒中的 `transport.setManager(manager)` 代码全部删除。

---

### 3. UDP 真实传输层实现

#### 3.1 UdpSocketTransport 核心设计
基于 Java 原生 `DatagramSocket`（UDP），无第三方依赖。

| 特性 | 实现方式 |
|------|----------|
| 异步接收 | 守护线程 + `socket.receive()` 阻塞循环 |
| 封包协议 | `[4字节payload长度][payload字节]`（长度前缀） |
| 客户端发现 | 握手协议 `[0xFF,0xFF,0xFF,0xFF]`，Server 收到后记录 Client 地址 |
| 多客户端支持 | `CopyOnWriteArrayList<InetSocketAddress>` 存储所有已连接 Client |
| 广播 | 遍历所有已知 Client 地址逐个发送 |
| 最大包体 | 4096 字节（可调整） |

#### 3.2 为什么选择原生 DatagramSocket 而非 Netty？
- 项目已依赖 TestNetty(0.8.0.2)，但其 API 是面向业务级的消息协议（Login/Message/Broadcast Packet），不适合直接传输 Netcode 的裸字节流
- 原生 DatagramSocket 零额外依赖、代码量仅 ~245 行、完全可控
- 未来可在此基础上平滑升级为 Netty 的 `NioDatagramChannel`（底层替换，接口不变）

---

### 4. 沙盒传输层切换

`NetcodeTankSandboxScreen` 新增传输层切换开关：

```java
private static final boolean USE_UDP = false;  // 切换传输层
private static final int UDP_PORT = 19100;
```

- `USE_UDP = false` → 使用 `LocalMemoryTransport`（同步、确定性、适合单机调试）
- `USE_UDP = true` → 使用 `UdpSocketTransport`（异步、有延迟、模拟真实网络环境）

HUD 层新增传输模式标签，运行时直观显示当前使用的传输层。

---

### 5. TDD 测试

#### 5.1 新增 UdpSocketTransportTest（3 个测试）
- `testServerBroadcastToClient` — Server 通过 UDP 广播数据，Client 回调接收完整字节
- `testClientSendToServer` — Client 通过 UDP 上行数据，Server 回调接收
- `testUdpWithNetworkManager_SpawnAndSync` — **全链路集成**：Spawn + StateSync 完全通过真实 UDP Socket，验证 NetworkManager 与 UdpSocketTransport 的端到端协作

#### 5.2 现有测试影响
- 原有 22 个 Netcode 测试（使用 LocalMemoryTransport）：**零改动，全部通过**
- 证明了传输层替换对上层业务完全透明

#### 5.3 测试总数
全量测试 **103/103 通过**（含业务测试 + Netcode 测试 + UDP 测试）。

---

### 6. 文件变更清单

#### 新增文件
| 文件 | 说明 |
|------|------|
| `TransportReceiveCallback.java` | 传输层统一数据接收回调接口 |
| `UdpSocketTransport.java` | UDP 真实网络传输层实现（~245行） |
| `UdpSocketTransportTest.java` | UDP 传输层 TDD 测试（3个用例） |

#### 修改文件
| 文件 | 变更 |
|------|------|
| `Transport.java` | 新增 `setReceiveCallback()` 接口方法 |
| `LocalMemoryTransport.java` | `manager` 字段替换为 `receiveCallback`，删除 `setManager()` |
| `NetworkManager.java` | `setTransport()` 自动注册回调 |
| `NetworkManagerTest.java` | MockTransport 实现新接口方法 |
| `DualEndpointIntegrationTest.java` | 删除 `setManager()` 调用 |
| `SpawnAutoDerivationTest.java` | 删除 `setManager()` 调用 |
| `RpcInvocationTest.java` | 删除 `setManager()` 调用 |
| `NetcodeTankSandboxScreen.java` | 泛化为 Transport 接口 + USE_UDP 开关 + HUD 标签 |

---

### 7. 下一步计划
1. **跨进程联机沙盒** — 拆分为独立的 Server 进程和 Client 进程，验证跨 JVM 联机
2. **Despawn 网络广播** — 实现实体销毁的 0x12 封包与双端清理
3. **网络延迟模拟** — 在 LocalMemoryTransport 上增加可配置延迟，测试弱网表现
