# 9. v0.4.1 联机状态同步实现报表

## 概述

根据 `3_0_联机状态同步策划案.md` 中规划的 6 阶段方案，完整实现了多人联机状态同步系统。  
解决了之前"各玩各的"问题——即联机时双方地图不同、敌人各自独立、攻击无法同步的核心缺陷。

## 实现范围

| 阶段 | 内容 | 状态 |
|------|------|------|
| Phase 1 | 统一地图种子 | ✅ 已完成 |
| Phase 2 | 敌人状态权威同步 | ✅ 已完成 |
| Phase 3 | 攻击请求→伤害结果 | ✅ 已完成 |
| Phase 4 | 玩家受伤广播 | ✅ 已完成 |
| Phase 5 | 换层同步 | ✅ 已完成 |
| Phase 6 | 扩展状态同步（HP/等级/ATK/DEF） | ✅ 已完成 |

## 架构设计

### 权威模型

```
  HOST（房主）= 游戏服务器 + 客户端
  CLIENT（加入方）= 纯客户端，无游戏逻辑权威
  Server（TestNetty）= 纯数据中继，不参与游戏逻辑
```

- **敌人 AI**：仅在 HOST 执行，CLIENT 接收快照渲染
- **伤害计算**：仅在 HOST 执行，CLIENT 发送攻击请求，HOST 返回伤害结果
- **地图生成**：HOST 生成种子 → 广播给 CLIENT → 双方用相同种子生成一致地图
- **换层**：仅 HOST 可触发，CLIENT 收到广播后重建地图

### 新增协议（5 个数据包）

| 命令字 | 类名 | 方向 | 用途 |
|--------|------|------|------|
| 47 | `LanEnemySyncBroadcastPacket` | HOST→CLIENT | 60Hz 敌人状态快照广播 |
| 48 | `LanAttackRequestPacket` | CLIENT→HOST | 客户端攻击请求（物理/魔法） |
| 49 | `LanDamageResultBroadcastPacket` | HOST→ALL | 伤害结果广播 |
| 50 | `LanPlayerHurtBroadcastPacket` | HOST→ALL | 玩家受伤广播 |
| 51 | `LanFloorChangeBroadcastPacket` | HOST→CLIENT | 换层信号（新种子+层数） |

### 数据流

```
CLIENT 按攻击键
  → sendAttackRequest("magic", x, y, dx, dy, atk)
  → Server 中继
  → HOST 收到 → processRemoteAttack()
    → 验证位置、查找敌人、计算伤害
    → broadcastDamageResult(enemyId, damage, remainHp, killed, attackerGuid, xpReward)
    → Server 中继
    → ALL CLIENTS 收到 → 播放伤害飘字 + 击杀奖励
```

## 修改文件清单

### 新增文件（6 个）

| 文件 | 说明 |
|------|------|
| `EnemyStateSnapshot.java` | 敌人状态 DTO（enemyId, 位置, HP, 动作, 时间戳） |
| `LanEnemySyncBroadcastPacket.java` | 敌人状态广播包（cmd=47） |
| `LanAttackRequestPacket.java` | 攻击请求包（cmd=48, 含 attackType/位置/ATK） |
| `LanDamageResultBroadcastPacket.java` | 伤害结果广播包（cmd=49） |
| `LanPlayerHurtBroadcastPacket.java` | 玩家受伤广播包（cmd=50） |
| `LanFloorChangeBroadcastPacket.java` | 换层广播包（cmd=51） |

### 修改文件（10 个）

| 文件 | 主要改动 |
|------|---------|
| **LanCommands.java** | 新增 5 个命令字常量（47-51） |
| **LanGameStartBroadcastPacket.java** | 增加 `mapSeed` 字段 |
| **LanGameStartRequestPacket.java** | 增加 `mapSeed` 字段 |
| **LanPlayerStateSnapshot.java** | 增加 hp/maxHp/atk/def/level 字段 |
| **LanPlayerSyncRequestPacket.java** | 增加 hp/maxHp/atk/def/level 字段 |
| **LanRoomPlayer.java** | 增加 hp/maxHp/atk/def/level 字段 |
| **LanNetworkEvent.java** | 新增 `FLOOR_CHANGE` 类型 + `gameStartWithSeed()` 工厂方法 |
| **GameEntity.java** | 新增 `enemyId` 字段（网络标识） |
| **LanMultiplayerService.java** | 大改：新增 5 个消息队列、10+ 个 API 方法、完整协议注册 |
| **SimpleGameScreen.java** | 大改：种子地图、客户端/房主分离逻辑、完整 `updateLan()` 重写 |
| **GrowthHelper.java** | 新增 `onEnemyKilledByNetwork()` 网络击杀升级检查 |
| **LanLobbyScreen.java** | `startGame()` 支持 mapSeed 生成与传递 |
| **LanPlaygroundScreen.java** | 适配 `sendLocalState` 新签名（补齐参数） |

## SimpleGameScreen 核心改动详解

### 地图生成（Phase 1）
- `buildMap(long seed)` 使用 `Random(seed)` 生成确定性地图
- 随机内墙数量 4-8 个，随机楼梯位置，保护玩家出生点 (4,4)
- HOST 和 CLIENT 使用相同种子 → 地图完全一致

### 敌人处理（Phase 2）
- `spawnEntities()`：CLIENT 跳过敌人生成（由 HOST 权威控制）
- `render0()`：CLIENT 跳过 `enemyAI.update()`
- `getEnemies()`：CLIENT 返回 `networkEnemies`（从广播解析），HOST 返回 `enemies`
- `updateLanClientEnemies()`：CLIENT 从快照创建/更新 `networkEnemyMap`，视觉坐标线性插值

### HOST 逻辑（Phase 2-4）
- `updateLanHost()`：
  - 每帧广播所有敌人的 `EnemyStateSnapshot`
  - 处理远程攻击请求（`drainAttackRequests` + `processRemoteAttack`）
  - 检查敌人攻击远程玩家（`checkEnemyAttackRemotePlayers`，曼哈顿距离 ≤1）

### 攻击流程（Phase 3）
- CLIENT 按攻击键 → `sendAttackRequest()` → HOST `processRemoteAttack()` → `broadcastDamageResult()`
- 物理攻击：CLIENT 使用 `findNetworkEnemyAt()` 检查目标是否存在
- 魔法攻击：CLIENT 直接发送请求，HOST 用 `CombatHelper.findEnemy()` 查找

### 换层（Phase 5）
- CLIENT 踩到楼梯 → 显示"等待房主触发换层"
- HOST 踩到楼梯 → 生成新种子 → `broadcastFloorChange()` → 本地重建
- CLIENT 收到换层广播 → `handleFloorChange()` → 用新种子重建地图 + 清空网络敌人缓存

### 状态同步（Phase 6）
- `sendLocalState()` 扩展为 10 参数（含 hp, maxHp, level, atk, def）
- `updateRemotePlayers()`：同步远程玩家 HP/等级到本地 GameEntity

## 已知限制 & 后续优化

| 项目 | 说明 |
|------|------|
| EnemyAI 靶标 | 当前仅追踪本地玩家。MVP 可接受，因 `checkEnemyAttackRemotePlayers()` 已覆盖远程玩家受伤。后续可改为追踪最近任意玩家 |
| 敌人重生 | 当前换层后由 HOST 重新 spawn，CLIENT 等待广播。无同层敌人重生机制 |
| 断线重连 | 未实现，CLIENT 断线后无法恢复状态 |
| 攻击判定延迟 | CLIENT 物理攻击需等 RTT 确认，体感约 1-2 帧延迟（局域网可接受） |
| 远程玩家 HP 条 | GameRenderer 已支持（血量不满时自动显示黄色 HP 条） |

## 编译验证

```
> .\gradlew.bat :examples:compileJava
BUILD SUCCESSFUL in 17s
```
