# Netcode 联机框架 · 综合能力报表

## 当前版本：v0.6.4 · 总代码量 ~1765 行（引擎 1035 + 测试 730）

---

## 一、核心引擎层（13 个源文件）

| 文件 | 行数 | 职责 |
|------|------|------|
| **NetworkManager** | 316 | 大脑。管理所有网络对象的生命周期、Spawn/Despawn、状态同步广播、RPC收发和反序列化 |
| **NetworkObject** | 102 | 网络实体容器。持有 netId、prefabId，挂载多个 NetworkBehaviour 组件 |
| **NetworkBehaviour** | 79 | 业务脚本基类。继承它来写坦克、子弹等游戏逻辑，内部自动反射发现 NetworkVariable |
| **NetworkVariable\<T\>** | 72 | 同步变量。包装任意类型值，带脏标记，值变化时自动被 tick 检出并广播 |
| **NetBuffer** | 70 | 序列化工具。读写 int/float/boolean/String/Color 到字节数组 |
| **Transport** | 20 | 传输层接口。定义 startServer/connect/broadcast/sendToServer 等方法 |
| **TransportReceiveCallback** | 14 | 传输层→管理器的统一数据回调接口 |
| **LocalMemoryTransport** | 86 | 内存传输层。同步直调，零延迟，专为单元测试和单机调试设计 |
| **UdpSocketTransport** | 209 | UDP 真实传输层。DatagramSocket + 握手协议 + 长度前缀封包 + 守护线程异步接收 |
| **NetworkPrefabFactory** | 12 | 预制体工厂接口。配合 spawnWithPrefab 实现自动派生 |
| **@ServerRpc** | 13 | RPC 注解标记（Client→Server 方向） |
| **@ClientRpc** | 12 | RPC 注解标记（Server→Client 方向） |
| **RpcScanner** | 30 | 反射扫描 Behaviour 类上的 RPC 方法 |

---

## 二、测试层（10 个测试文件，30 个用例，全绿）

| 测试文件 | 用例数 | 覆盖内容 |
|----------|--------|----------|
| NetworkVariableTest | 2 | 脏标记检测：setValue → isDirty → clearDirty |
| NetworkObjectTest | 2 | 对象容器：addComponent + 自动反射装配变量 |
| NetworkBehaviourReflectionTest | 1 | 反射自动发现 private/public NetworkVariable |
| NetBufferTest | 1 | 序列化/反序列化：int/float/boolean/String(含中文) |
| NetworkManagerTest | 2 | 单端 Spawn + tick 状态广播 |
| DualEndpointIntegrationTest | 1 | 双端全链路：Spawn → 改值 → tick → Client 自动同步 |
| SpawnAutoDerivationTest | 3 | 预制体自动派生：spawnWithPrefab → Client 自动创建副本 + 多组件 |
| RpcMethodReflectionTest | 3 | RPC 注解扫描和反射方法定位 |
| RpcInvocationTest | 3 | ServerRpc(Client→Server) + ClientRpc(Server→Client) 双向调用 |
| UdpSocketTransportTest | 3 | 真实 UDP 广播/上行/全链路 Spawn+StateSync |

---

## 三、可视化沙盒（NetcodeTankSandboxScreen）

左右分屏实时对战演示，左半屏 = Server 世界线，右半屏 = Client 世界线：

- P1（橙色）WASD 移动 + J 射击
- P2（青色）方向键移动 + Enter 射击
- 子弹碰撞 → 扣血 → 死亡灰色 → 3秒复活
- HUD 显示当前传输层模式
- 改 `USE_UDP = true` 并重启可切换到真实 UDP 传输

---

## 四、四大核心能力

### 能力 1：状态同步
- **原理**：Server 每帧 `tick()` 扫描所有 NetworkVariable 的脏标记，有变化就自动序列化广播给 Client
- **使用方式**：继承 NetworkBehaviour，声明 `NetworkVariable<Float> x = new NetworkVariable<>(0f)`，改值用 `x.setValue()`，Client 端自动收到新值
- **封包格式**：`[0x10][netId][dirtyCount][varIndex,value]...`

### 能力 2：Spawn 自动派生
- **原理**：Server 调 `spawnWithPrefab(prefabId)` → 自动广播 SpawnPacket → Client 端用同 prefabId 的工厂自动创建本地副本
- **使用方式**：双端 `registerPrefab(id, factory)` 注册同样的工厂，然后 Server 端 `spawnWithPrefab(id)`
- **封包格式**：`[0x11][netId][prefabId]`

### 能力 3：RPC 双向调用
- **原理**：`@ServerRpc` 方法 Client→Server 调用，`@ClientRpc` 方法 Server→Client 调用，参数自动序列化/反序列化，通过反射在目标端执行
- **使用方式**：在 Behaviour 里写 `@ClientRpc public void rpcXxx(float a, int b)`，调用端 `sendClientRpc("rpcXxx", a, b)`
- **封包格式**：`[0x20或0x21][netId][behaviourIdx][methodName][argCount][args...]`
- **支持参数类型**：int, float, boolean, String

### 能力 4：传输层可插拔
- **原理**：LocalMemoryTransport 和 UdpSocketTransport 实现相同 Transport 接口，通过 `NetworkManager.setTransport()` 注入，自动注册回调
- **使用方式**：改 `USE_UDP = true` 并重启，上层业务代码零改动
- **UDP 协议**：握手 `[0xFF×4]`，数据封包 `[4字节长度][payload]`

---

## 五、架构全景图

```
┌─────────────────────────────────────────────────────┐
│                   游戏逻辑层                          │
│  TankBehaviour extends NetworkBehaviour              │
│  ├─ NetworkVariable<Float> x, y, rot                │
│  ├─ NetworkVariable<Integer> hp                      │
│  ├─ @ClientRpc rpcSpawnBullet(...)                  │
│  └─ 业务代码: 移动、射击、碰撞                        │
├─────────────────────────────────────────────────────┤
│              NetworkManager (核心调度)                 │
│  ├─ spawn / spawnWithPrefab  → 实体生命周期管理       │
│  ├─ tick()                   → 脏变量扫描 + 广播     │
│  ├─ onReceiveData()          → 封包反序列化分发       │
│  └─ sendRpcPacket()          → RPC 序列化发送        │
├─────────────────────────────────────────────────────┤
│              Transport (传输层接口)                    │
│  ├─ LocalMemoryTransport  → 同步内存直调 (TDD/调试)  │
│  └─ UdpSocketTransport    → 真实UDP网络 (联机)       │
└─────────────────────────────────────────────────────┘
```

---

## 六、版本演进路线

| 版本 | 里程碑 | 对应报表 |
|------|--------|----------|
| v0.3.2 | 全系统实装（旧架构） | 报表 2 |
| v0.4.0~v0.4.1 | 联机模块分层、广播修复、同步架构、序列化分析 | 报表 3~9 |
| v0.6.0 | **Netcode 重写**：NetworkVariable 脏标记 + NetBuffer 序列化 + 内存传输 + 沙盒 | 报表 10~11 |
| v0.6.1 | NetBuffer 自动同步落地，移除沙盒假同步 | 报表 12 |
| v0.6.2 | Spawn 自动派生机制（预制体工厂 + SpawnPacket 广播） | 报表 13 |
| v0.6.3 | RPC 双向调用机制（@ServerRpc / @ClientRpc + 反射分发） | 报表 13 |
| v0.6.4 | Transport 统一回调 + UdpSocketTransport 真实 UDP 传输层 | 报表 14 |

---

## 七、传输层切换详解

### LocalMemoryTransport（默认）
- 两个 Transport 实例通过 `connectToPeer()` 互相持有引用
- `broadcast()` = 直接调用对端 Java 方法，**同步**、零延迟、确定性
- 适合：单元测试、TDD 驱动开发、单机调试

### UdpSocketTransport（USE_UDP = true）
- Server 端绑定 `0.0.0.0:19100` 端口监听
- Client 端随机本地端口，向 `127.0.0.1:19100` 发送 `[0xFF×4]` 握手包
- Server 收到握手后记录 Client 地址（CopyOnWriteArrayList）
- 所有数据封包格式：`[4字节payload长度][payload字节]`
- 后台守护线程异步接收，通过 receiveCallback 推送到 NetworkManager
- 注意：因为异步，Spawn 后需轮询等待 Client 完成派生才能获取引用
- 未来跨机器联机：把 `127.0.0.1` 换成对方局域网 IP 即可

---

## 八、下一步可选方向

| 优先级 | 功能 | 说明 |
|--------|------|------|
| 高 | Despawn 网络广播 | 实体销毁的 0x12 封包与双端清理 |
| 高 | 跨进程联机 | 拆为独立 Server/Client 进程（当前是单 JVM 双端模拟） |
| 中 | 沙盒 HUD 按钮切换传输层 | 点击按钮切换 static 变量 + 重建 Screen |
| 中 | 网络延迟模拟 | LocalMemoryTransport 加可配置延迟，测试弱网表现 |
| 低 | 断线重连 | Client 心跳超时检测 + 重连握手 |
| 低 | 可靠有序传输 | UDP 上层加序号/确认/重传（当前裸 UDP 可能丢包） |
