Created 2 todos

审计项目代码设计问题

Starting: *制定重构方案* (2/2)

审计完成，现在来看一下实际的代码深度确认几个关键细节，再制定方案：

Completed: *制定重构方案* (2/2)

---

## 设计原则审计 & 重构方案

### 一、审计结果总览

审计了 13 个核心文件（~3,450 行），按严重程度分级：


| 级别   | 数量 | 分布                                                 |
| ------ | ---- | ---------------------------------------------------- |
| **高** | 6    | SimpleGameScreen ×5, InputManager ×1               |
| **中** | 8    | SimpleGameScreen ×4, InputManager ×3, StatData ×1 |
| **低** | 10   | 散布各处                                             |

**设计亮点（值得保留）**：`CombatEngine`（纯函数）、`WeaponRange`/`StatType`（枚举+数据）、`VirtualButton`（单一职责）、`DeathPenalty.calcPenalty()`（计算与副作用分离）。

---

### 二、Top 5 问题诊断

#### #1 SimpleGameScreen 是上帝类（871行，10+ 种职责） — **高**

它同时承担：地图生成、实体管理、玩家输入、敌人AI、碰撞检测、物理/魔法/穿透战斗、成长升级、死亡惩罚、地图渲染、实体渲染、HUD渲染、死亡UI、飘字系统。

#### #2 战斗扫描逻辑重复 3~4 次 — **高**

`performRangedAttack()`、`performMagicAttack()`、`tryAttackPlayer()`、敌人近战（`updateEnemies` 内）都包含几乎相同的"沿方向扫描 → 碰墙中断 → 命中伤害 → 飘字 → 击杀处理"逻辑。

#### #3 Entity 是大型 public 内部类，数据与行为耦合 — **高**

Entity 集成了坐标、视觉插值、冷却、AI、成长、战斗扩展全部字段，且内嵌 `updateVisuals()`、`triggerBump()`、`getMoveCooldown()` 等行为。同样 `DamagePopup` 也不应是内部类。

#### #4 大量硬编码魔法数字 — **中**

MP回复率 `0.05f`、游荡概率 `0.3f`、空闲冷却因子 `0.5f`、金币=经验/2、bump偏移 `0.3f`、敌人配置参数直接内联。

#### #5 InputManager 上帝类（1039行）+ 三套平行 switch — **高**（但本次不动）

---

### 三、权衡实际与规范的重构方案

**原则：功能不变，分步渐进，每步可编译可测试。**

考虑到这是一个**快速迭代的游戏原型**（v0.3.x），过度拆分会降低开发效率。以下方案只做**高收益低风险**的结构优化，不引入框架级抽象：

#### 阶段一：提取数据类（低风险、高收益）


| 步骤 | 内容                                                            | 目标                 |
| ---- | --------------------------------------------------------------- | -------------------- |
| 1a   | `Entity` → 独立顶级类 `GameEntity.java`（screens/main/ 包下）  | 消除内部类滥用       |
| 1b   | `DamagePopup` → 独立顶级类 `DamagePopup.java`                  | 消除内部类滥用       |
| 1c   | 敌人配置参数 →`EnemyDefs.java` 静态配置类（枚举或静态工厂）    | 消除硬编码，数据驱动 |
| 1d   | 游戏常量 →`GameConfig.java`（MP_REGEN_RATE、WANDER_CHANCE 等） | 消除魔法数字         |

#### 阶段二：提取逻辑系统（中风险、高收益）


| 步骤 | 内容                                                                         | 目标                  |
| ---- | ---------------------------------------------------------------------------- | --------------------- |
| 2a   | 战斗扫描 →`CombatHelper.scanAndAttack(...)` 静态方法                        | 消除 3~4 处重复逻辑   |
| 2b   | 成长逻辑 →`GrowthHelper.onEnemyKilled() / onPlayerDeath() / autoAllocate()` | SimpleGameScreen 减负 |
| 2c   | 敌人AI →`EnemyAI.update(entity, player, map)` 静态方法                      | 职责分离              |

#### 阶段三：渲染分离（中风险、中收益）


| 步骤 | 内容                                                                                | 目标                          |
| ---- | ----------------------------------------------------------------------------------- | ----------------------------- |
| 3a   | `GameRenderer.java`（drawMap、drawEntities、drawPopups、drawHUD、drawDeathOverlay） | SimpleGameScreen 只剩胶水逻辑 |

#### 不做的事（权衡后搁置）


| 项目                          | 原因                                                                       |
| ----------------------------- | -------------------------------------------------------------------------- |
| InputManager 拆分             | 1039行虽大，但它是引擎层稳定代码，改动影响面广，与游戏玩法迭代无关，ROI 低 |
| StatData 计算逻辑外迁         | 作者 TODO 表明属性模型本身要重设计，现在拆只是搬家，等模型确定再重构       |
| 接口抽象（Movable/Combatant） | 原型阶段增加接口层会减慢迭代速度，等 Entity 种类 >3 种时再引入             |
| JSON 数据驱动                 | 当前只有 4 种敌人，Java 静态配置已够用，等配置 >10 时再迁移                |

#### 重构后的 SimpleGameScreen 预期结构

```java
// 重构后 SimpleGameScreen 约 250~300 行（从 871 行降到原来的 1/3）
public class SimpleGameScreen extends GScreen {
    // 配置常量 → GameConfig.xxx
    // Entity/DamagePopup → 独立文件
    // 敌人定义 → EnemyDefs.create(...)
  
    void create()      { ... spawnEntities(); }
    void render0()     { update(delta); GameRenderer.draw(...); }
    void updatePlayer(){ ... CombatHelper.scanAndAttack(...); }
    void updateEnemies(){ EnemyAI.update(...); }
    // 成长事件 → GrowthHelper.onEnemyKilled(...)
    // 战斗事件 → CombatHelper.scanAndAttack(...)
}
```

#### 文件清单预估

```
screens/main/
  SimpleGameScreen.java  (250行, 原871) — 胶水层
  GameEntity.java        (90行)  — 实体数据+视觉插值
  DamagePopup.java       (20行)  — 飘字数据
  GameConfig.java        (30行)  — 游戏常量
  EnemyDefs.java         (40行)  — 敌人配置工厂
  CombatHelper.java      (120行) — 战斗扫描+伤害+飘字
  GrowthHelper.java      (60行)  — 升级/死亡/分配
  EnemyAI.java           (50行)  — AI决策
  GameRenderer.java      (200行) — 全部渲染
```

---

要开始执行吗？建议按 **阶段一 → 二 → 三** 顺序逐步推进，每步编译验证。
