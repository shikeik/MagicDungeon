# 程序化纹理生成系统设计案 (Revised)

## 1. 核心设计理念

本系统的核心目标是构建一个**轻量级、可视化、AI友好**的纹理生成工具链。
它不再追求构建一套独立的绘图语言，而是直接利用 Java 反射机制，将 `NeonBatch` 的强大绘图能力直接暴露给 JSON 数据。

**核心原则：**
1.  **直接映射 (Direct Mapping):** JSON 指令 = `NeonBatch` 方法调用。
    - 优点：零学习成本（只要会用 `NeonBatch` 就会写指令），功能与引擎渲染能力完全同步。
    - 实现：维持 `MethodRegistry` 扫描机制，但精简其依赖。
2.  **可视化优先:** 提供所见即所得的编辑器，支持指令回放与调试。
3.  **资产化输出:** 生成的纹理可直接导出为 PNG，作为静态资源在游戏中使用。

---

## 2. 架构重构方案

### 2.1 运行时 (Runtime Core)
保留原有的反射执行核心，但进行解耦和瘦身。

*   **NeonDrawExecutor (执行器):**
    - **职责:** 解析 JSON 列表，按顺序反射调用 `NeonBatch` 方法。
    - **改进:** 移除对旧版 `AssetUtils` 的依赖，改为纯粹的 `Map<InternalPath, Texture>` 资源引用。
    - **API 风格:**
      ```json
      {
        "op": "drawCircle",
        "args": [100, 100, 50, 100, 100, 50], // x, y, radiusinner, x, y, radiusouter (根据方法签名)
        "color": "#FF0000",
        "filled": true
      }
      ```
*   **MethodRegistry (注册表):**
    - **职责:** 启动时扫描 `NeonBatch` 所有 `public` 方法，建立 `MethodName -> MethodHandle` 映射。
    - **改进:** 增加参数类型自动匹配逻辑（如 `int` 转 `float`），提高 JSON 编写的容错率。

### 2.2 编辑器工具 (NeonTextureEditor)
这是本次重构的重心，一个用于生成、预览、调试纹理的独立工具场景。

#### 功能模块：
1.  **实时预览 (Live Preview):**
    - 左侧为渲染画布，实时显示当前 JSON 指令的绘制结果。
    - 支持缩放、平移，支持切换背景色（黑/白/透明格）。
2.  **指令编辑器 (Code/Inspector):**
    - 右侧提供 JSON 文本编辑区域。
    - (可选) 提供常用指令的快捷插入按钮 (Circle, Rect, Line)。
3.  **笔画回放器 (Stroke Replay):**
    - **核心功能:** 提供一个进度条 (Slider)，范围 `0 ~ totalCmds`。
    - **作用:** 当拖动滑块时，只绘制前 N 条指令。
    - **场景:** 用于调试复杂的叠加效果，看清楚每一层是如何覆盖的。
4.  **参数调试 (Hot Tweaking):**
    - 选中某条指令时，可直接在属性面板修改其数值（如颜色、坐标），实时更新 JSON。
5.  **导出功能 (Export):**
    - **Save to PNG:** 将当前 FBO 内容保存为文件。
    - **Export JSON:** 保存当前指令集为模板。

### 2.3 依赖清理
*   **移除:** 旧版 `AIDrawTestScreen` 中复杂的 UI 组件（如 GridView, FileIndexer）。
*   **移除:** `AssetUtils` 中对于文件系统的扫描索引（改为直接指定路径或即时扫描）。
*   **保留:** `TextureExporter` 的 FBO 读写核心逻辑。

---

## 3. 工作流 (Workflow)

### 3.1 AI 辅助生成
1.  **Prompt:** 用户告诉 AI: "生成一个发光的魔法符文，外圈是蓝色圆环，中间是紫色十字。"
2.  **Code Gen:** AI 基于 `NeonBatch` API 生成 JSON 数据。
3.  **Import:** 用户将 JSON 粘贴到编辑器。
4.  **Debug:** 使用"笔画回放器"检查绘制顺序。
5.  **Refine:** 微调颜色和线条粗细。
6.  **Export:** 导出 `rune_magic.png` 到游戏资源目录。

### 3.2 动态生成 (In-Game)
*   游戏运行时，可以直接加载 JSON 模板，动态替换颜色参数（如将所有红色替换为绿色），然后渲染到 FBO 生成新的技能图标。

---

## 4. 关键技术点

### 4.1 动态 API 映射
```java
// 伪代码：执行器核心逻辑
public void render(Batch batch, List<DrawCommand> commands, int stepLimit) {
    int currentStep = 0;
    for (DrawCommand cmd : commands) {
        if (currentStep >= stepLimit) break; // 回放控制
        
        MethodHandle method = registry.get(cmd.op);
        Object[] args = convertArgs(cmd.args, method.type());
        
        // 设置颜色状态
        batch.setColor(cmd.color); 
        
        // 执行绘制
        method.invokeWithArguments(batch, args);
        currentStep++;
    }
}
```

### 4.2 FBO 与 坐标系
*   **坐标归一化:** 建议 JSON 中使用 0.0~1.0 的相对坐标，渲染时根据 FBO 尺寸 (如 512x512) 进行缩放。这样生成的纹理可以是任意分辨率。
*   **抗锯齿:** 导出时支持超采样 (Render at 2x -> Downscale) 以获得更高质量的图标。

---

## 5. 总结
本设计旨在打造一个**"程序员的画板"**。
通过移除不必要的工程依赖，专注于 JSON 指令到像素的转换，我们能获得一个轻量、高效且极具扩展性的纹理生成工具。它完美契合 AI 生成内容的需求，让开发者(或 AI)能像写代码一样画图。
