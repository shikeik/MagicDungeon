# 输入系统重构与设计文档

## 1. 现有系统总结 (MagicDungeon_Old)

### 1.1 核心架构
*   **InputManager (单例模式):** 作为输入系统的核心入口，负责管理所有输入逻辑。
*   **InputAction (枚举):** 定义了游戏逻辑动作（如 `MOVE_UP`, `ATTACK`, `UI_CONFIRM` 等），将具体按键与游戏行为解耦。
*   **模拟输入 (Simulation):** 支持虚拟按键的模拟触发，允许外部（如UI按钮）直接触发 `InputAction`。
*   **输入映射 (Mappings):** 维护了 `keyboardMappings` (键盘) 和 `controllerMappings` (手柄) 两套映射表，支持运行时重新绑定。
*   **自动切换模式:** 检测到手柄输入时自动切换到 `KEYBOARD` 模式（隐藏鼠标），检测到鼠标移动时切换回 `MOUSE` 模式。

### 1.2 优点
*   **逻辑解耦:** `InputAction` 的设计非常成功，业务逻辑层无需关心具体按键，只关心动作。
*   **调试支持:** 内置了详细的 `DLog` 日志，方便追踪输入源和按键事件。
*   **虚拟映射层:** 引入了 `V_BUTTON_*` 虚拟按钮概念，试图统一不同手柄的物理按键差异（如 Xbox A vs Switch B）。

### 1.3 存在的问题
*   **设备适配硬编码:** `InputManager` 中存在大量针对特定设备（如 "Switch Pro", "Android"）的硬编码检测，扩展性差，难以维护。
*   **输入模式定义模糊:** 只有 `MOUSE` 和 `KEYBOARD` 两种模式，无法准确区分 "纯键盘"、"手柄" 和 "触控" 场景。
*   **平台耦合:** 平台判断逻辑 (`Gdx.app.getType()`) 散落在 Manager 内部，不利于跨平台统一处理。
*   **轮询与事件混合:** 同时使用了 `ControllerListener` (事件回调) 和 `update()` 中的轮询逻辑，虽然是为了处理 Axis 死区，但增加了复杂度和潜在的冲突。

---

## 2. 新输入系统设计 (MagicDungeon)

### 2.1 设计目标: 双平台三输入端统一
我们追求的是**无缝切换**且**体验一致**的输入系统。
*   **PC 平台:**
    *   **Keyboard (键鼠):** 传统 WASD + 鼠标瞄准/UI交互，作为PC端默认操作方式。
    *   **Gamepad (纯手柄):** 物理手柄操作，自动隐藏鼠标光标。
*   **Android 平台:**
    *   **Touch (虚拟触控):** 屏幕上的虚拟摇杆和按钮，默认操作方式。
    *   **Gamepad (蓝牙手柄):** 连接物理手柄时，自动适配并可能隐藏虚拟UI。
    *   **Keyboard (外接键鼠):** 同样支持外接键盘操作（通过 OTG 或蓝牙），逻辑与PC一致。

### 2.2 核心架构设计

#### 2.2.1 输入源抽象 (InputProvider)
将底层的不同输入硬件抽象为 **InputProvider**，它们负责“翻译”原始硬件信号，不再在 Manager 中写死逻辑。

1.  **KeyboardProvider:**
    *   **职责:** 统一处理 **键盘按键** (Gdx.input.isKeyPressed) 和 **鼠标点击/移动**。
    *   **归属:** 对应 `InputType.KEYBOARD`。
    *   **统一性:** 在PC上它是默认激活的；在Android上它也是备用的（应对外接键盘）。

2.  **GamepadProvider:**
    *   **职责:** 处理物理手柄连接 (Controllers)，映射 Axis 和 Buttons。
    *   **归属:** 对应 `InputType.GAMEPAD`。
    *   **特性:** 支持热插拔，当检测到有效输入（推杆 > 死区 或 按键）时，抢占 `InputType` 为 `GAMEPAD`。

3.  **VirtualInputProvider (UI层注入):**
    *   **职责:** **接收**来自 UI 层（虚拟摇杆、虚拟按钮）的信号，并将其**注入**到输入系统中。
    *   **归属:** 对应 `InputType.TOUCH`。
    *   **统一性关键:** 它是系统中唯一“虚拟”的 Provider，它的数据来源不是 Gdx.input，而是 UI 事件回调。

#### 2.2.2 输入模式枚举 (InputType)
用于驱动 UI 表现（如 "按E交互" vs "按A交互"）和准星显示逻辑。

```java
public enum InputType {
    KEYBOARD, // 键鼠组合 (PC标准 / Android外接)
    GAMEPAD,  // 物理手柄 (Xbox / PS / Switch)
    TOUCH     // 纯触控 (仅 Android 显示虚拟UI)
}
```

### 2.3 虚拟按键的统一设计 (In-Depth)

为了彻底解决“为虚拟摇杆单独写一套移动逻辑”的问题，我们采用 **信号注入 (Signal Injection)** 的设计模式。

#### 2.3.1 核心理念：虚拟即物理
虚拟按键（Virtual Joystick / Buttons）在输入系统看来，就是一个 **“特殊的硬件驱动”**。
业务逻辑层（PlayerController）**永远只询问 InputSystem**，不询问 UI 组件。

#### 2.3.2 实现机制：注入管道
`InputSystem` 提供一套**注入接口**，供 UI 层调用。

```java
public class InputSystem {
    // 注入状态缓存
    private final Set<InputAction> simulatedActions = new HashSet<>();
    private final Vector2 simulatedAxisLeft = new Vector2();
    private final Vector2 simulatedAxisRight = new Vector2(); // 右摇杆/瞄准

    // 1. 动作注入 (对应按钮按下/松开)
    public void injectAction(InputAction action, boolean isPressed) {
        if (isPressed) {
            simulatedActions.add(action);
            // 只要有触摸输入，就切换模式为 TOUCH
            setInputType(InputType.TOUCH); 
        } else {
            simulatedActions.remove(action);
        }
    }

    // 2. 轴向注入 (对应摇杆)
    public void injectAxis(int axisCode, float x, float y) {
        if (axisCode == AXIS_LEFT) {
            simulatedAxisLeft.set(x, y);
        } else if (axisCode == AXIS_RIGHT) {
            simulatedAxisRight.set(x, y);
        }
        
        // 如果摇杆被推动，也切换模式
        if (Math.abs(x) > 0.1f || Math.abs(y) > 0.1f) {
            setInputType(InputType.TOUCH);
        }
    }
}
```

#### 2.3.3 UI层 (View) 的职责变化
UI 组件（如 `VirtualJoystick` 类）不再直接控制玩家，而是变成了一个**信号发生器**。

*   **VirtualButton:** 
    *   `touchDown` -> `InputSystem.injectAction(InputAction.ATTACK, true)`
    *   `touchUp` -> `InputSystem.injectAction(InputAction.ATTACK, false)`
*   **VirtualJoystick:**
    *   `act(delta)` -> 计算 knob 位置 -> `InputSystem.injectAxis(AXIS_LEFT, percentX, percentY)`

#### 2.3.4 业务层 (Controller) 的统一调用
```java
// PlayerController.java
public void update(float delta) {
    // 1. 获取移动向量 (自动合并了 Keyboard WASD / Gamepad Stick / Virtual Stick)
    Vector2 moveDir = InputSystem.getAxis(InputAxis.LEFT); 
    
    // 2. 检查动作
    if (InputSystem.isJustPressed(InputAction.ATTACK)) {
        player.attack();
    }
}
```
通过这种设计，`PlayerController` 完全不需要知道信号是来自键盘、手柄还是屏幕触摸。

### 2.4 数据结构优化

**统一映射配置 (InputProfile):**
```json
{
  "profileName": "Default",
  "actions": {
    "ATTACK": {
      "keyboard": [ "J", "X", "MOUSE_LEFT" ],  // 键鼠统一映射
      "gamepad": [ "BUTTON_X", "BUTTON_R1" ]   // 物理手柄映射
    },
    // 虚拟按键不需要配置在这里，因为它们是硬编码绑定的 UI 控件
    "MOVE_UP": {
      "keyboard": [ "W", "UP" ],
      "gamepad": [ "DPAD_UP" ]
    }
  }
}
```

### 2.5 平台适配策略

| 平台 | 默认 InputType | 硬件响应 | UI 表现 |
| :--- | :--- | :--- | :--- |
| **PC** | KEYBOARD | 键盘/鼠标总是有效。插入手柄可切换至 GAMEPAD。 | 始终隐藏虚拟摇杆。提示图标随 InputType 切换。 |
| **Android** | TOUCH | 触摸屏幕有效。插入手柄/键盘可切换。 | 默认显示虚拟摇杆。检测到 GAMEPAD/KEYBOARD 输入时，淡出虚拟摇杆；触摸屏幕时淡入。 |

## 3. 下一步计划

1.  **重构 InputManager:** 拆分为 `InputSystem` 并移除单例模式（建议作为 GameContext 的一部分，或者保持单例但重构内部）。
2.  **实现 Providers:** 编写 `KeyboardProvider` 和 `GamepadProvider`。
3.  **实现注入机制:** 在 System 中添加 `inject` 接口。
4.  **UI 改造:** 修改现有的 UI 摇杆代码，使其调用 `inject` 接口而非直接控制角色。
5.  **资源分离:** 将 InputProfile 配置文件与代码分离，支持多套预设。

