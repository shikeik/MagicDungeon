收到代码了。我看完了你提供的 `core` 和 `examples` 的核心代码。

**一句话总结：**
你的项目**底子非常好**（自研 ECS、Neon 骨骼动画、NeonBatch 渲染栈都很有水平），但目前的架构处于**“引擎与游戏逻辑通过 `Gd` 和 `examples` 包强耦合”**的尴尬阶段。

关于你的问题：“先删代码变干净，还是先提取 `Gd`？”

**我的建议是：优先提取并重构 `Gd`。**

理由如下：
1.  **解耦核心**：`Gd` 是脚本和引擎交互的门户。如果不先把它定下来，你删减面条代码时会发现到处都在报错，因为大家都依赖 `Gd`。
2.  **确立边界**：把 `Gd` 移入 `core` 并通过**依赖注入**的方式初始化，能强迫你划清“什么是引擎（Core）”和“什么是编辑器/游戏（Client）”的界限。
3.  **保留参考**：`Fighter.java` 等面条代码虽然要重写，但其中包含的业务逻辑（如判定、状态机切换细节）是很好的参考素材，**建议先不动它们，等新架构跑通后再逐步迁移逻辑并删除**。

---

### 第一步：手术方案 —— 将 `Gd` 移入 Core

目前的 `examples/.../editor/Gd.java` 有一个致命问题：**它在 `init` 方法里直接 `new EditorGameInput`**。而 `EditorGameInput` 依赖编辑器 UI（ViewWidget），这导致 `Gd` 无法独立存在于 `core` 中。

我们需要把 `Gd` 变成一个纯粹的**静态服务容器（Service Locator）**。

#### 1. 修改目标：`core/src/main/java/com/goldsprite/magicdungeon/core/Gd.java`

请在 `core` 模块新建这个类，并替换掉 `examples` 里的 `Gd`。

```java
package com.goldsprite.magicdungeon.core;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Audio;
import com.badlogic.gdx.Files;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Graphics;
import com.badlogic.gdx.Input;
import com.goldsprite.magicdungeon.core.scripting.IScriptCompiler;

/**
 * 引擎核心 API 入口 (Facade Pattern)
 * 职责：提供给脚本或游戏逻辑唯一的静态访问点。
 * 所有的实现类由启动器 (Launcher/Editor) 注入，Gd 本身不依赖具体实现。
 */
public class Gd {
    // --- 基础模块 (LibGDX 原生) ---
    public static Files files = Gdx.files;
    public static Application app = Gdx.app;
    public static Audio audio = Gdx.audio;

    // --- 核心代理 (可能被编辑器 Hook) ---
    public static Input input = Gdx.input;       // 默认指向 Gdx.input，编辑器会注入代理
    public static Graphics graphics = Gdx.graphics; // 默认指向 Gdx.graphics

    // --- 引擎模块 ---
    public static final Config config = new Config();
    public static IScriptCompiler compiler;

    /**
     * 初始化引擎环境 (依赖注入)
     * @param inputImpl 具体的输入实现 (实机为 Gdx.input, 编辑器为 EditorGameInput)
     * @param graphicsImpl 具体的图形实现 (实机为 Gdx.graphics, 编辑器为 EditorGameGraphics)
     * @param compilerImpl 脚本编译器
     */
    public static void init(Input inputImpl, Graphics graphicsImpl, IScriptCompiler compilerImpl) {
        if (inputImpl != null) input = inputImpl;
        if (graphicsImpl != null) graphics = graphicsImpl;
        if (compilerImpl != null) compiler = compilerImpl;
    }

    // 配置类保持不变
    public static class Config {
        public float logicWidth = 960;
        public float logicHeight = 540;
        public ViewportType viewportType = ViewportType.FIT;
    }

    public enum ViewportType { FIT, EXTEND, STRETCH }
}
```

**改动重点：**
*   **移除了 `init` 中的 `new EditorGameInput(...)`**。
*   `init` 方法改为接收 `Input` 和 `Graphics` 接口。
*   这样 `Gd` 类就**没有任何 `examples` 包的依赖**了，可以安全地放在 `core` 里供所有脚本调用。

---

### 第二步：适配调用端 (EditorController)

由于 `Gd` 变了，你需要修改 `examples/.../editor/EditorController.java` 的初始化逻辑。

**修改 `create()` 方法：**

```java
// EditorController.java

public void create() {
    // ... 前面的 UI 初始化代码 ...

    // 创建具体的实现类 (这些类保留在 examples 包里，因为它们依赖 ViewWidget)
    EditorGameInput editorInput = new EditorGameInput(gameWidget);
    EditorGameGraphics editorGraphics = new EditorGameGraphics(gameTarget);

    // 【关键】通过依赖注入初始化 Core 层的 Gd
    // 注意：这里需要把 Gd 的包名引用改为 com.goldsprite.magicdungeon.core.Gd
    Gd.init(editorInput, editorGraphics, Gd.compiler); // 保持原有的 compiler 引用或从 Launcher 传递

    // ... 后续代码 ...
}
```

---

### 第三步：清理代码（减重建议）

既然你要重构引擎，以下代码建议按如下方式处理：

#### 1. 应该保留并移动到 `core` 的代码 (Engine Core)
这些是你的核心轮子，必须保留：
*   `com.goldsprite.magicdungeon.ecs.**` (整个 ECS 系统，包括 Skeleton)
*   `com.goldsprite.magicdungeon.neonbatch.**` (渲染核心)
*   `com.goldsprite.magicdungeon.core.scripting.**` (脚本接口)
*   `com.goldsprite.magicdungeon.log.**` (调试控制台非常好用)
*   `com.goldsprite.magicdungeon.ui.widget.**` (通用 UI 组件，如 `SkewBar`, `BioCodeEditor`)

#### 2. 应该保留在 `examples` 作为参考的代码 (Reference)
不要删，但不要让 `core` 依赖它们：
*   `EditorGameInput` / `EditorGameGraphics`: 这是编辑器专属逻辑。
*   `MagicDungeonEditorScreen` / `MagicDungeonHubScreen`: 这是工具链界面。

#### 3. **建议删除或重写的代码 (Legacy / Spaghetti)**
这些代码耦合度高，且非引擎通用功能，是本次重构的重点清理对象：

*   **`examples/.../editor/GameWorld.java`**:
	*   **问题**: 这个类名与 `core.ecs.GameWorld` 冲突，且逻辑混乱（既管渲染又管资源加载）。
	*   **建议**: **删除**。用 `core.ecs.GameWorld` 统一管理。场景初始化逻辑应放入一个 `Scene` 或 `Script` 中。

*   **`examples/.../solofight/modules/Fighter.java`**:
	*   **问题**: 典型的 "God Class"。包含状态机、输入处理、渲染、音效、碰撞。
	*   **建议**: **保留作为参考，但在新游戏中完全重写**。拆分为 `PlayerControllerSystem` (输入), `CombatSystem` (判定), `AnimationGraph` (动画状态)。

*   **`examples/.../solofight/input/ComboEngine.java`**:
	*   **问题**: 硬编码了具体的招式逻辑。
	*   **建议**: **泛型化**。重构为 `InputSequenceSystem`，允许通过配置表（JSON）定义连招，而不是写死 `if (prev == CROUCH && curr == DASH)`.

*   **`examples/.../solofight/modules/Platform.java`**:
	*   **问题**: 简单的 POJO。
	*   **建议**: **删除**。用 ECS 的 `GObject` + `BoxColliderComponent` 代替。

---

### 第四步：解决双重 `GameWorld` 冲突

目前项目里有两个 `GameWorld`：
1.  `core.ecs.GameWorld`: 单例，管理 ECS 系统循环。 (**这是正统**)
2.  `examples.editor.GameWorld`: 只是一个包含 PlayerTexture 和 Batch 的简单类。 (**这是冒牌货**)

**操作建议：**
直接删除 `examples/src/.../editor/GameWorld.java`。
在 `RealGame.java` 和 `EditorController.java` 中，使用 `core.ecs.GameWorld.inst()` 来驱动游戏。

---

### 总结行动路线

1.  **移动 Gd**: 在 `core` 创建新的 `Gd` 类（代码如上）。
2.  **修正引用**: 修改 `EditorController` 和 `RealGame`，使用新的 `Gd.init(...)` 注入依赖。
3.  **统一世界**: 删除 `examples` 里的 `GameWorld`，强迫自己使用 ECS 的 `core.ecs.GameWorld`。
4.  **按需清理**: 现在你可以放心地去删除 `solofight` 包里那些不需要的测试 Screen 了，只要 `Gd` 还在，核心引擎就能跑。

如果你准备好了，**请先执行第一步（移动 Gd）**，如果遇到编译报错（通常是包名引用问题），可以再把报错信息发给我，我帮你修。
