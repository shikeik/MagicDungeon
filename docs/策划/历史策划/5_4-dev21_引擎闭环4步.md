老师，既然“内功”（架构）已经修炼完毕，现在的目标非常明确：**打通编辑器 UI 与游戏容器的“任督二脉”**。

我的想法是将整个流程串联起来，形成一个完整的 **Build 和 Run** 闭环。

### 核心思路：一键启动 (One-Click Run)

我们需要在 `GDEngineEditorScreen` 中改造那个目前只负责保存的逻辑，将其升级为真正的“运行”逻辑。

整个流程可以拆解为以下 **4 个阶段**：

#### 1. 预处理阶段 (Pre-flight Check)
*   **自动保存**：用户点击“Run”时，必须先强制保存当前编辑的文件到磁盘。因为编译器是去读取磁盘文件的，内存里的修改编译器看不见。
*   **确定上下文**：
	*   **项目路径**：直接从 `GDEngineHubScreen.ProjectManager.currentProject` 获取。
	*   **入口类名**：目前我们先约定死（Convention over Configuration），入口类固定为 `com.game.Main`。或者，稍微灵活一点，尝试读取 `project.json` 里的配置（如果之前 Hub 创建项目时写入了的话）。

#### 2. 编译阶段 (Build)
*   **异步执行**：编译是耗时操作（尤其是在手机上），绝对不能卡住 UI 线程。我们需要开一个 `new Thread`。
*   **调用编译器**：使用 `Gd.compiler.compile(className, projectPath)`。
*   **日志反馈**：这一步至关重要。编译器的输出（包括成功或报错信息）必须实时打到 `DebugConsole` 上，这样用户才知道是不是分号写漏了。

#### 3. 加载与实例化阶段 (Load 和 Link)
*   **反射验证**：拿到编译好的 `Class<?>` 后，不能直接跑。
	*   先检查：它是否实现了我们刚定义的 `IGameScriptEntry` 接口？
	*   如果没实现（比如用户写了个普通类），报错提示“入口类必须实现 IGameScriptEntry”。
*   **实例化**：调用 `clazz.newInstance()` 创建脚本对象。

#### 4. 运行阶段 (Run)
*   **切换屏幕**：回到主线程 (`Gdx.app.postRunnable`)。
*   **启动容器**：调用 `ScreenManager.getInstance().setCurScreen(new GameRunnerScreen(scriptInstance))`。
*   **见证奇迹**：此时，屏幕应该从编辑器跳转到游戏画面，`GameRunnerScreen` 会调用脚本的 `onStart`，我们在脚本里写的逻辑（比如创建方块）就会在画面上动起来。

---

### 具体行动计划

我们不需要创建新文件，主要是在 **`GDEngineEditorScreen`** 里编写逻辑。

1.  **修改顶部工具栏**：
	*   把 "Save" 按钮保留。
	*   把 "Apply" 或 "Run" 按钮的点击事件重写。

2.  **实现 `buildAndRun()` 私有方法**：
	*   按上述 4 个阶段编写逻辑。
	*   重点处理异常捕获：编译错误、实例化错误、类型转换错误，都要通过 `Debug.logT` 或 `Toast` 告诉用户。

3.  **处理“返回”体验**：
	*   当用户在游戏画面中按“返回键”或调用 `exit` 时，`ScreenManager` 的 `popLastScreen()` 机制应该能让用户无缝回到代码编辑器，继续修改代码。这一点我们的架构天然支持，不需要额外代码。

### 待确认的细节

**关于入口类名 (`Main.java`)**：
目前您的 Hub 创建项目时，默认生成的是 `com.game.Main`。
*   **建议**：我们暂时 **硬编码** 入口为 `com.game.Main`。
*   **理由**：先跑通流程。如果要支持自定义入口，需要在编辑器里加一个配置框，或者解析 `project.json`，这会增加当前任务的复杂度。

**如果您同意这个思路，且确认入口类暂时锁定为 `com.game.Main`，我将给出 `GDEngineEditorScreen` 的修改代码。**
