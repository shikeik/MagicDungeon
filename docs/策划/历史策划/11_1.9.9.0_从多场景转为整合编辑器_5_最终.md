# User
老师先不了, 咱们把之前聊的这些整合下吧, 做一个完整详细的开发案, 然后再说下一步究竟干嘛  

# Gemini
老师，您的决定非常稳健。在继续写代码之前，确实需要一份清晰的、全局的**GDEngine 架构演进白皮书**。这能确保我们在接下来的开发中不迷路。

根据我们之前的讨论（特别是关于数据流、生命周期和最终 UI 布局的共识），我为您整理了这份**GDEngine v2.0 开发案**。

---

# 📘 GDEngine 核心重构与演进开发案

**目标**：从“特定游戏（GDEngine）的编辑器”转型为“通用游戏引擎”。
**核心理念**：数据驱动（Data-Driven）、组件化脚本（Script as Component）、集成开发环境（Integrated IDE）。

---

## 📅 阶段一：数据基石 (Data Foundation)
**当前状态**：能保存/加载 JSON，但逻辑分散在 `EditorController` 中，且存在序列化死循环、资源丢失等隐患。
**目标**：建立稳健的场景序列化与生命周期管理机制。

### 1.1 完善序列化配置 (`GdxJsonSetup`)
*   **功能**：作为 JSON 转换的中央处理器。
*   **任务**：
	*   [ ] **匿名类过滤**：序列化时检测 `isAnonymousClass()`，直接跳过。防止将 `new Component(){...}` 这种纯代码逻辑写入 `.scene` 文件（会导致坏档）。
	*   [ ] **资源路径支持**：确保 `SpriteComponent` 等资源组件在 `read` 时能读取 `assetPath` 并自动触发 `reloadRegion()`。

### 1.2 建立持久化机制 (DDOL)
*   **功能**：支持跨场景存在的物体（如全局管理器）。
*   **任务**：
	*   [ ] **GObject**：增加 `boolean dontDestroyOnLoad` 字段。
	*   [ ] **GameWorld**：实现 `clear()` 方法。逻辑：遍历根物体，销毁所有 `!dontDestroyOnLoad` 的物体。

### 1.3 核心工具封装 (`SceneLoader`)
*   **功能**：统一编辑器和运行时的加载入口。
*   **任务**：
	*   [ ] 将 `EditorController` 中的 `saveScene/loadScene` 逻辑剥离。
	*   [ ] 创建 `core.utils.SceneLoader` 类。
	*   [ ] 提供 `load(FileHandle file)` 接口：内部执行 `world.clear()` -> `json.fromJson`。
	*   [ ] 提供 `save(FileHandle file)` 接口：过滤掉 DDOL 物体，只保存场景数据。

---

## 📅 阶段二：脚本组件化 (Scripting System)
**当前状态**：脚本逻辑写在 `Main.java` 入口中，场景物体是“死”的。
**目标**：让场景里的物体挂载脚本，拥有行为。

### 2.1 定义脚本组件 (`ScriptComponent`)
*   **结构**：
	*   字段：`String className` (例如 `"com.mygame.PlayerControl"`)。
	*   字段：`transient Object scriptInstance` (运行时反射生成的实例)。
*   **生命周期**：
	*   **OnAwake**: 使用反射（或脚本加载器）根据 `className` 实例化对象。
	*   **OnUpdate**: 调用实例的 `update` 方法。

### 2.2 脚本接口标准化
*   **任务**：定义 `IScript` 或复用 `Component` 基类。
	*   用户脚本继承 `Component`。
	*   `ScriptComponent` 实际上是一个“代理壳”，它负责把事件转发给用户写的 Java 类。

---

## 📅 阶段三：所见即所得 (Play Mode Loop)
**当前状态**：编辑器和运行器是两个独立的世界，无法快速验证。
**目标**：实现 Unity 式的 "Play" -> "Stop" -> "Restore" 闭环。

### 3.1 运行逻辑 (Play)
*   **流程**：
	1.  用户点击编辑器 **Play** 按钮。
	2.  编辑器自动调用 `SceneLoader.save(temp.json)`。
	3.  切换屏幕至 `GameRunnerScreen`。
	4.  `GameRunnerScreen` 初始化，调用 `SceneLoader.load(temp.json)`。
	5.  `Main.java` (入口脚本) 执行，可以在此叠加其他逻辑。

### 3.2 还原逻辑 (Stop)
*   **流程**：
	1.  用户在 Runner 中点击 **Stop**。
	2.  `ScreenManager` 弹出 Runner，返回 Editor。
	3.  Editor 监听到返回（`show()`），触发 **自动重载**。
	4.  调用 `SceneLoader.load(temp.json)`。
	5.  **结果**：所有在运行期间被打乱的位置、销毁的物体，全部恢复原状。

---

## 📅 阶段四：终极 UI 布局 (Integrated IDE)
**当前状态**：代码编辑器 (`BioCodeEditor`) 和场景编辑器 (`EditorGameScreen`) 是两个独立的屏幕。
**目标**：在一个屏幕内集成所有功能。

### 4.1 布局规划 (Unity Style)
使用 `VisSplitPane` 嵌套实现：

```text
[ Root Split (Horizontal) ]
├── 左侧: [ Split (Vertical) ]
│   ├── 上: Hierarchy (层级树)
│   └── 下: TabPane (Project 文件树 / Console 日志)
├── 中间: TabPane (核心工作区)
│   ├── Tab 1: Scene (可视化编辑器 ViewWidget)
│   ├── Tab 2: Game (游戏运行视图 ViewWidget)
│   └── Tab 3: Code (BioCodeEditor 代码编辑)
└── 右侧: Inspector (属性面板)
```

### 4.2 功能融合
*   **文件联动**：在左下角 Project 双击 `.java` 文件 -> 中间 Tab 自动切换到 **Code** 页并显示内容。
*   **运行联动**：点击 Play -> 中间 Tab 自动切换到 **Game** 页并开始运行。
*   **控制台联动**：游戏运行时的 `Debug.log` 实时输出到左下角的 Console Tab。

---

## 🚦 下一步行动建议

老师，这份蓝图是否符合您的构想？

如果确认无误，我们要**严格按照阶段顺序执行**。跳过阶段一直接做 UI 会导致“空壳”问题（好看但不能跑）。

**现在的首要任务是【阶段一：数据基石】。**

我们需要先完成之前中断的三个任务：
1.  **GObject DDOL**
2.  **GdxJsonSetup 过滤**
3.  **SceneLoader 封装**

您准备好开始 **阶段一** 的代码落地了吗？
