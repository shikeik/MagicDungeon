# 死亡与重生系统设计方案

## 1. 概述
当前游戏在玩家生命值归零后仅显示"游戏结束"文本，缺乏完整的死亡流程和重玩机制。本方案旨在完善游戏的死亡与重生逻辑，增强游戏的完整性。

## 2. 死亡逻辑 (Death Logic)

### 2.1 触发条件
*   当玩家当前生命值 (`hp`) 降至 `0` 或更低时触发。

### 2.2 死亡表现
*   **状态锁定**：玩家无法进行移动、攻击、使用物品等操作。
*   **视觉反馈**：
    *   角色可能会播放死亡动画（如有）或变灰/倒下。
    *   屏幕应用红色滤镜或灰阶滤镜，提示玩家已死亡。
*   **音效**：播放悲伤或沉重的死亡音效。
*   **UI 显示**：
    *   隐藏常规 HUD（可选）。
    *   弹出模态窗口 "GAME OVER"。

### 2.3 游戏进程处理
*   停止怪物 AI 更新（防止怪物继续攻击尸体）。
*   停止时间流逝或计时器。

## 3. 重生/重开逻辑 (Respawn/Restart Logic)

鉴于本作 Roguelike 的性质，采用 **永久死亡 (Permadeath)** 机制。

### 3.1 游戏结束界面
界面包含以下内容：
*   **标题**：大号字体 "你死掉了" 或 "GAME OVER"。
*   **统计信息**（可选）：
    *   到达层数
    *   击杀怪物数
    *   获得金币/分数
*   **操作按钮**：
    *   **[重新开始]**：开始新的一局游戏。
    *   **[退出游戏]**：关闭程序或返回主菜单。

### 3.2 重新开始流程
点击 [重新开始] 后：
1.  **数据重置**：
    *   玩家属性重置为初始值（1级，满血满蓝）。
    *   背包和装备清空。
    *   经验值清空。
2.  **世界重置**：
    *   地牢层数重置为 1。
    *   生成新的随机种子。
    *   重新生成第 1 层地牢地图、怪物和物品。
    *   清空历史层级数据 (`visitedLevels`)。
3.  **状态恢复**：
    *   关闭游戏结束窗口。
    *   解除输入锁定。
    *   恢复正常游戏循环。

## 4. 技术实现要点

### 4.1 GameScreen 状态机
引入游戏状态枚举：
```java
public enum GameState {
    RUNNING,
    PAUSED,
    GAME_OVER
}
```
`updateLogic` 方法需根据当前状态决定是否执行游戏逻辑。

### 4.2 GameHUD 更新
新增 `GameOverWindow` 类或在 `GameHUD` 中添加相关 UI 组件（Window, Label, TextButton）。

### 4.3 数据清理
确保 `restartGame()` 方法能彻底清理上一局的残留数据（特别是静态变量或单例引用，如有）。
