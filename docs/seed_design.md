# 固定种子系统设计方案

## 1. 背景与目标
当前游戏中，地图生成、怪物分布和物品生成均依赖于全局随机数生成器（`MathUtils.random()` 和 `Math.random()`）。这意味着每次重新进入游戏或重新生成关卡时，结果都是不可预测且不一致的。
为了解决“每次重进后场景不一致”的问题，并满足“固定层级布局、怪物分布”的需求，我们需要引入**基于种子的随机数生成系统**。

## 2. 核心需求
1.  **可复现性**：给定相同的种子，生成的地图布局（房间、走廊、楼梯位置）必须完全一致。
2.  **一致性**：给定相同的种子，生成的实体（怪物类型、位置、属性）和物品（类型、位置）必须完全一致。
3.  **层级关联**：不同层级的生成应该基于主种子派生，或者每层有独立的种子计算规则（例如：`LayerSeed = GlobalSeed + LevelIndex`），确保整局游戏的生成序列固定。

## 3. 技术方案

### 3.1. 随机数生成器替换
弃用不可控的全局随机源：
*   ❌ `Math.random()`
*   ❌ `MathUtils.random()` (在关卡生成逻辑中)

引入可控的局部随机源：
*   ✅ `java.util.Random` 或 `com.badlogic.gdx.math.RandomXS128` (LibGDX自带，性能更好)

### 3.2. 数据结构变更

#### `Dungeon` 类
*   新增字段 `long seed`：用于记录当前关卡的种子。
*   新增字段 `RandomXS128 rng`：当前关卡专用的随机数生成器实例。
*   `generate()` 方法：初始化 `rng`，并将其传递给生成子系统。

#### `MapGenerator` 类
*   `generate()` 方法签名修改，增加 `RandomXS128 rng` 参数。
*   内部所有 `MathUtils.random()` 调用替换为 `rng` 的相关调用（如 `rng.nextInt()`, `rng.nextFloat()`）。

#### `GameScreen` 类
*   `spawnEntities()` 方法：不再使用 `Math.random()`，改为使用 `dungeon.rng`。
*   确保实体生成的顺序是固定的（例如先生成怪物，再生成物品，且遍历顺序确定）。

### 3.3. 种子策略
为了保证整局游戏体验的一致性，建议采用以下种子策略：
*   **初始种子**：在游戏开始时（`MainMenuScreen` -> `GameScreen`）生成或指定一个 `GlobalSeed`。
*   **层级种子**：每一层的种子由 `GlobalSeed` 和 `LevelIndex` 共同决定。
    *   公式示例：`CurrentLevelSeed = GlobalSeed ^ (LevelIndex * 2654435761L)` (简单的哈希混合)
    *   这样可以保证即使玩家多次通过第 1 层，进入第 2 层时，第 2 层的内容也是固定的。

## 4. 实施步骤

1.  **重构 `MapGenerator`**
    *   将内部的随机逻辑抽取，替换为接受 `RandomXS128` 实例。
2.  **重构 `Dungeon`**
    *   添加种子管理逻辑。
    *   提供 `getRandomWalkableTile(RandomXS128 rng)` 方法，确保获取位置的随机性也是可控的。
3.  **重构 `GameScreen`**
    *   在 `spawnEntities` 中使用 `dungeon.rng` 替代 `Math.random()`。
    *   确保调用顺序：先生成地图 -> 重置 `rng` (可选，或继续使用) -> 生成实体。
    *   *注：为了让地图和实体分布独立调整，也可以考虑使用两个独立的随机流，但通常一个流按顺序调用即可。*

## 5. 预期效果
修改完成后，只要在代码中或配置文件中固定初始种子，无论启动多少次游戏，第 N 层的地图结构、怪物种类和位置都将完全相同。

## 6. 讨论点
*   是否需要支持玩家手动输入种子？（目前需求未明确，暂按代码固定或随机生成但可记录处理）
*   存档系统是否需要保存种子？（需要，以便加载游戏后能恢复后续层的生成序列） -> *当前存档系统似乎只存了玩家状态，如果需要恢复关卡状态，需要保存种子。*

---
*待确认后开始编码。*
