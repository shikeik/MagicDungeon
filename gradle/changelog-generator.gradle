import groovy.json.JsonOutput

// TODO: 项目大了(commits几万个)之后可以做增量生成, 不过那是几年后的事了, 如果我没弃坑的话
// ============================================================
// [配置区] 全局参数设置
// ============================================================
ext {
	// 回溯多少个版本 (Tag)？设大一点以包含旧历史
	MAX_VERSIONS = 100

	// 每个版本最多抓取多少条 Commit？(防止巨型合并撑爆内存)
	MAX_COMMITS_PER_VER = 500
}

tasks.register('generateChangelog') {
	group = "gdengine"
	description = "Generate hierarchical changelog.json with Tag Messages"

	doLast {
		def jsonFile = rootProject.file("docs/engine_docs/changelog/changelog.json")
		jsonFile.parentFile.mkdirs()

		println "⏳ [Changelog] Reading Git Tags..."
		def tags = getGitOutput("git tag --sort=-version:refname").readLines()

		// 1. 版本数量限制
		if (tags.size() > MAX_VERSIONS) {
			tags = tags.subList(0, MAX_VERSIONS)
			println "⚠️ [Changelog] History limited to latest ${MAX_VERSIONS} versions."
		}

		// 分组容器
		def groupedData = [:] as LinkedHashMap

		// 1. 处理 Unreleased (HEAD)
		// 注意：如果是全新项目无Tag，tags为空，这里会跳过。建议初始化项目至少打一个 v0.0.1
		if (!tags.isEmpty()) {
			def unreleased = getCommitsBetween(tags[0], "HEAD", MAX_COMMITS_PER_VER)
			if (!unreleased.isEmpty()) {
				def devKey = "In Development"
				groupedData[devKey] = []
				groupedData[devKey] << [
					tag: "HEAD",
					fullVersion: "HEAD",
					date: new Date().format("yyyy-MM-dd"),
					// HEAD 没有 Tag Message，给个默认的
					tagSummary: "正在开发中...",
					tagDetails: "包含自上个版本以来的最新改动。",
					isSnapshot: true,
					commits: unreleased
				]
			}
		}

		// 2. 处理 Tag 列表
		for (int i = 0; i < tags.size(); i++) {
			def currentTag = tags[i]
			def prevTag = (i == tags.size() - 1) ? "" : tags[i+1]

			// --- [新增] 获取 Tag Message ---
			// %(contents) 会获取完整的附注信息
			def rawTagMsg = getGitOutput("git for-each-ref refs/tags/${currentTag} --format='%(contents)'")
			def tagSummary = ""
			def tagDetails = ""

			if (rawTagMsg && !rawTagMsg.trim().isEmpty()) {
				def lines = rawTagMsg.readLines()
				// 第一行是总结
				if (!lines.isEmpty()) {
					// [修改] 增加 replaceAll 去除首尾引号
					tagSummary = lines[0].trim().replaceAll(/^['"]|['"]$/, "")
					// 剩余行是细节 (如果有的话)
					if (lines.size() > 1) {
						tagDetails = lines.subList(1, lines.size()).join("\n").trim().replaceAll(/^['"]|['"]$/, "")
					}
				}
			} else {
				// 如果没有附注(轻量标签)，默认用 Tag 名
				tagSummary = "Release ${currentTag}"
			}

			// --- 版本号解析 ---
			def cleanTag = currentTag.replace("v", "")
			def mainVersion = cleanTag

			// 只匹配前三位 X.Y.Z (这样 1.10.12.10 和 1.10.12.5 都会归入 1.10.12 组)
			def matcher = (cleanTag =~ /^(\d+\.\d+\.\d+)/)
			if (matcher.find()) {
				mainVersion = matcher.group(1)
			} else {
				mainVersion = cleanTag // 比如 HappyNewYear 这种非数字Tag
			}

			if (!groupedData.containsKey(mainVersion)) {
				groupedData[mainVersion] = []
			}

			println "⏳ Processing ${currentTag} -> Group: ${mainVersion}"

			def tagDate = getGitOutput("git log -1 --format=%ad --date=short ${currentTag}")
			def commits = getCommitsBetween(prevTag, currentTag, MAX_COMMITS_PER_VER)

			// 添加到组
			groupedData[mainVersion] << [
				tag: currentTag,
				fullVersion: cleanTag,
				date: tagDate,
				// [新增] 写入 Tag 信息
				tagSummary: tagSummary,
				tagDetails: tagDetails,
				isSnapshot: false,
				commits: commits
			]
		}

		// 3. 构建最终 JSON
		def finalGroups = []
		groupedData.each { key, patches ->
			finalGroups << [
				id: key,
				patches: patches
			]
		}

		def finalJson = [
			// [修复] 强制使用北京时间 (Asia/Shanghai)
			lastUpdated: new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone("Asia/Shanghai")),
			groups: finalGroups
		]

		def jsonString = JsonOutput.prettyPrint(JsonOutput.toJson(finalJson))
		jsonFile.write(jsonString, "UTF-8")

		println "✅ Changelog Generated: ${finalGroups.size()} groups."
	}
}

// --- Helpers ---

def getCommitsBetween(String fromRef, String toRef, int maxCount) {
	def range = fromRef.isEmpty() ? toRef : "${fromRef}..${toRef}"

	// [核心修复] 定义极低概率冲突的分隔符，替代单字符 '|'
	// 防止 Commit 内容或作者名中包含 '|' 导致分割错位
	def DELIMITER = "__GD_SEP__"

	// 使用 maxCount 限制查询数量
	def rawLog = getGitOutput("git log ${range} -n ${maxCount} --pretty=format:%H${DELIMITER}%ad${DELIMITER}%an${DELIMITER}%B[END_C] --date=short")

	def commits = []
	if (rawLog == null || rawLog.trim().isEmpty()) return commits

	rawLog.split("\\[END_C\\]").each { rawEntry ->
		if (rawEntry.trim().isEmpty()) return

		// [修改] 使用自定义分隔符分割
		def parts = rawEntry.split(DELIMITER, 4)
		if (parts.length < 4) return

		def hash = parts[0].trim()
		def date = parts[1].trim()
		// parts[2] 是作者名，虽然 JSON 目前没存，但为了索引对齐必须占位
		def fullMessage = parts[3].trim()

		// [修改] 优化正则：允许冒号后有0个或多个空格 (兼容 'fix:bug' 写法)
		// 原正则: ...: (.+) 强制一个空格
		def matcher = (fullMessage =~ /^(feat|fix|perf|docs|refactor|chore|test)(\((.+)\))?:\s*(.+)/)

		if (matcher.find()) {
			def type = matcher.group(1)
			def summary = matcher.group(4)
			def lines = fullMessage.readLines()
			def details = (lines.size() > 1) ? lines.subList(1, lines.size()).join("\n").trim() : ""

			commits << [
				hash: hash, date: date, type: type, summary: summary, details: details
			]
		} else {
			def lines = fullMessage.readLines()
			def summary = lines.isEmpty() ? "No Description" : lines[0].trim()
			if (!summary.startsWith("Merge branch") && !summary.startsWith("Merge remote-tracking")) {
				def details = (lines.size() > 1) ? lines.subList(1, lines.size()).join("\n").trim() : ""
				commits << [
					hash: hash, date: date, type: "legacy", summary: summary, details: details
				]
			}
		}
	}
	return commits
}

def getGitOutput(String command) {
	try {
		def proc = command.execute(null, rootProject.rootDir)
		def out = new StringBuilder()
		def err = new StringBuilder()
		proc.consumeProcessOutput(out, err)
		proc.waitFor()
		if (out.length() > 0) return out.toString().trim()
		return ""
	} catch (Exception ignored) { return "" }
}
