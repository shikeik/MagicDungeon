import java.security.MessageDigest
import groovy.json.JsonOutput
import java.text.SimpleDateFormat

ext {
	CHUNK_SIZE = 18 * 1024 * 1024
	DOCS_ROOT = file("docs")
	BUILD_TMP = file("build/tmp_publish")
	DIST_DIR = file("dist")
}

tasks.register('packageDocs', Zip) {
	group = 'gdengine-publish'
	from DOCS_ROOT
	include 'engine_docs/**'
	archiveFileName = 'docs_full.zip'
	destinationDirectory = BUILD_TMP
	doFirst { BUILD_TMP.mkdirs() }
}

tasks.register('buildDocsDist') {
	group = 'gdengine-publish'
	dependsOn 'packageDocs'
	outputs.upToDateWhen { false } // å¼ºåˆ¶è¿è¡Œ

	doLast {
		def sourceZip = file("${BUILD_TMP}/docs_full.zip")
		if (!sourceZip.exists()) throw new GradleException("Source zip missing!")

		// 1. ç”Ÿæˆæž„å»º ID (æ—¶é—´æˆ³: yyyyMMdd_HHmmss)
		// è¿™å°†ä½œä¸ºæ–‡ä»¶åçš„ä¸€éƒ¨åˆ†ï¼Œå¼ºåˆ¶ç©¿é€ CDN ç¼“å­˜
		def dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss")
		dateFormat.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"))
		def buildID = dateFormat.format(new Date())

		println "ðŸš€ Starting Docs Build. ID: ${buildID}"

		// 2. æ¸…ç† dist ç›®å½•ä¸‹çš„æ—§æ–‡æ¡£æ–‡ä»¶
		if (!DIST_DIR.exists()) DIST_DIR.mkdirs()
		DIST_DIR.listFiles().each { f ->
			// åˆ é™¤æ—§çš„æ¸…å•å’Œåˆ†å· (åŒ¹é… docs.*.p*.zip)
			if (f.isFile() && (f.name == "docs_manifest.json" || f.name.startsWith("docs."))) {
				f.delete()
			}
		}

		def partsList = []
		def buffer = new byte[CHUNK_SIZE]
		int partIndex = 0

		sourceZip.withInputStream { ins ->
			while (true) {
				int bytesRead = ins.read(buffer)
				if (bytesRead <= 0) break

				// A. ä¸´æ—¶æ–‡ä»¶è®¡ç®— MD5 (ä»…ç”¨äºŽæ ¡éªŒï¼Œä¸å†ç”¨äºŽæ–‡ä»¶å)
				File tempPart = new File(DIST_DIR, "temp_part_${partIndex}")
				tempPart.withOutputStream { it.write(buffer, 0, bytesRead) }
				String md5 = generateMD5(tempPart)

				// B. [æ ¸å¿ƒ] ç”Ÿæˆå¸¦ BuildID çš„æ–‡ä»¶å
				// æ ¼å¼: docs.{BuildID}.p{Index}.zip
				// ä¾‹å¦‚: docs.20240120_123000.p0.zip
				String finalName = String.format("docs.%s.p%d.zip", buildID, partIndex)
				File finalFile = new File(DIST_DIR, finalName)
				tempPart.renameTo(finalFile)

				// C. [æ ¸å¿ƒ] å†™å…¥ç›¸å¯¹è·¯å¾„ (çº¯æ–‡ä»¶å)
				// ä¸åŒ…å« https å‰ç¼€ï¼Œç”±å®¢æˆ·ç«¯è‡ªç”±ç»„è£… CDN åœ°å€
				partsList << [
					index: partIndex,
					file: finalName,
					md5: md5,
					size: finalFile.length()
				]

				println "   -> Generated: ${finalName} (Size: ${finalFile.length()})"
				partIndex++
			}
		}

		def manifest = [
			name: "engine_docs.zip",
			totalSize: sourceZip.length(),
			version: projectVersion,
			buildId: buildID, // è®°å½• ID æ–¹ä¾¿è°ƒè¯•
			updatedAt: new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone("Asia/Shanghai")),
			parts: partsList
		]

		File jsonFile = new File(DIST_DIR, "docs_manifest.json")
		jsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(manifest))

		println "âœ… Docs Build Complete. Manifest generated at dist/docs_manifest.json"
	}
}

static def generateMD5(File file) {
	MessageDigest digest = MessageDigest.getInstance("MD5")
	file.withInputStream { is ->
		byte[] buffer = new byte[8192]
		int read
		while ((read = is.read(buffer)) > 0) digest.update(buffer, 0, read)
	}
	return digest.digest().encodeHex().toString()
}
